<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>hello_world</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../struct_tech_tut.html">hide_me</a></li><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded "><a href="../examples/wasm-bindgen_guide.html"><strong aria-hidden="true">1.</strong> nobundle version</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/001.hello_world.html" class="active"><strong aria-hidden="true">1.1.</strong> hello_world</a></li><li class="chapter-item expanded "><a href="../examples/002.console_log.html"><strong aria-hidden="true">1.2.</strong> console_log</a></li><li class="chapter-item expanded "><a href="../examples/003.importing_non-browser_JS.html"><strong aria-hidden="true">1.3.</strong> importing_non-browser_JS</a></li><li class="chapter-item expanded "><a href="../examples/004.working_with_the_char_type.html"><strong aria-hidden="true">1.4.</strong> working_with_the_char_type</a></li><li class="chapter-item expanded "><a href="../examples/005.wasm-in-wasm.html"><strong aria-hidden="true">1.5.</strong> wasm-in-wasm</a></li><li class="chapter-item expanded "><a href="../examples/006.DOM.html"><strong aria-hidden="true">1.6.</strong> DOM</a></li><li class="chapter-item expanded "><a href="../examples/007.closures.html"><strong aria-hidden="true">1.7.</strong> closures</a></li><li class="chapter-item expanded "><a href="../examples/008.performance.html"><strong aria-hidden="true">1.8.</strong> performance</a></li><li class="chapter-item expanded "><a href="../examples/009.fetch.html"><strong aria-hidden="true">1.9.</strong> fetch</a></li><li class="chapter-item expanded "><a href="../examples/010.weather_report.html"><strong aria-hidden="true">1.10.</strong> weather_report</a></li><li class="chapter-item expanded "><a href="../examples/011.canvas.html"><strong aria-hidden="true">1.11.</strong> canvas</a></li><li class="chapter-item expanded "><a href="../examples/012.julia_set.html"><strong aria-hidden="true">1.12.</strong> julia_set</a></li><li class="chapter-item expanded "><a href="../examples/013.web_audio.html"><strong aria-hidden="true">1.13.</strong> web_audio</a></li><li class="chapter-item expanded "><a href="../examples/014.webgl.html"><strong aria-hidden="true">1.14.</strong> webgl</a></li><li class="chapter-item expanded "><a href="../examples/015.websockets.html"><strong aria-hidden="true">1.15.</strong> websockets</a></li><li class="chapter-item expanded "><a href="../examples/016.webrtc_datachannel.html"><strong aria-hidden="true">1.16.</strong> webrtc_datachannel</a></li><li class="chapter-item expanded "><a href="../examples/017.request-animation-frame.html"><strong aria-hidden="true">1.17.</strong> request-animation-frame</a></li><li class="chapter-item expanded "><a href="../examples/018.paint.html"><strong aria-hidden="true">1.18.</strong> paint</a></li><li class="chapter-item expanded "><a href="../examples/019.wasm-in-web-worker.html"><strong aria-hidden="true">1.19.</strong> wasm-in-web-worker</a></li><li class="chapter-item expanded "><a href="../examples/020.raytrace-parallel.html"><strong aria-hidden="true">1.20.</strong> raytrace-parallel</a></li><li class="chapter-item expanded "><a href="../examples/021.wasm-audio-worklet.html"><strong aria-hidden="true">1.21.</strong> wasm-audio-worklet</a></li><li class="chapter-item expanded "><a href="../examples/022.todomvc.html"><strong aria-hidden="true">1.22.</strong> todomvc</a></li></ol></li><li class="chapter-item expanded "><a href="../canvas2d/canvas2d.html"><strong aria-hidden="true">2.</strong> Canvas 2d</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../canvas2d/dummy.html"><strong aria-hidden="true">2.1.</strong> dummy</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<!-- Introduction - Essential summary of the tutorial -->
<p><em>This is the classic "Hello, world!" example.</em>
The original example comes from the <a href="https://rustwasm.github.io/wasm-bindgen/examples/hello-world.html" target="_blank">[wasm-bindgen example]</a></p>
<!-- Overview - The problem you are trying to solve with the tutorial -->
<p>The purpose of this first contact with wasm is to show you how to</p>
<ul>
<li>set up a project,</li>
<li>export a Rust function to Js,</li>
<li>call it from Js,</li>
<li>and inversly call the Js alert function from Rust.*</li>
</ul>
<!-- Prerequisites - What the reader must have before getting started. -->
<p>It is assumed that you have installed Rust on your local machine</p>
<p><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></p>
<p>or visit the official <a href="https://www.rust-lang.org/tools/install" target="_blank">Rust install page</a></p>
<!-- Lab - Step-by-step instructions -->
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-examples-in-7-steps"><a class="header" href="#converting-examples-in-7-steps">Converting Examples in 7 steps</a></h2>
<h4 id="1-set-up-your-file-structure"><a class="header" href="#1-set-up-your-file-structure">1. Set up your file structure</a></h4>
<pre><code class="language-sh">cargo new hello_world --lib
cd hello_world
mkdir -p www/html www/js
</code></pre>
<p>You should have this file structure</p>
<pre><code class="language-sh">.
├── Cargo.toml
├── src
│   └── lib.rs
└── www
    ├── html
    └── js
</code></pre>
<p>Throughout this Guide, we will keep rust code in <code>src</code> and frontend code in <code>www</code></p>
<h4 id="2-edit-cargotoml-set-the-crate-type-and-add-wasm-bindgen-as-a-dependency"><a class="header" href="#2-edit-cargotoml-set-the-crate-type-and-add-wasm-bindgen-as-a-dependency">2. Edit Cargo.toml: Set the crate-type and add wasm-bindgen as a dependency.</a></h4>
<p>In Cargo.toml, put <code>crate-type = ["cdylib"]</code> after <code>edition</code> entry.</p>
<p>And add wasm-bindgen as a dependency.</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasm-bindgen = "0.2.88"
</code></pre>
<p>Note:</p>
<p><code>wasm-bindgen-cli</code> will be installed when we build with wasm-pack the first time.</p>
<p><em>(You don't need and should not install it yourself unless you are willing to manage versions for various dependencies.)</em></p>
<h4 id="3-get-the-librs-code-for-hello_world"><a class="header" href="#3-get-the-librs-code-for-hello_world">3. Get the lib.rs code for hello_world</a></h4>
<p>To maintaint consistency with the original Examples and demonstrate the steps to convert to a nobundle version, we'll cut and paste and modify those examples whenever possible.</p>
<p>The point is to get used to convert code meant to be deployed
with NPM-Webpack ecosystem into a play vanilla no-bundle Rust wasm code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;

//This is using the alert function from Js
#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
}

//This Rust function will be called from Js
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!("Hello, {}!", name));
}
<span class="boring">}</span></code></pre></pre>
<p>So in this contrived example we are going to call a Wasm function from Js
that will call a Js function passing a value from Wasm to Js in the process.</p>
<h4 id="4-specify-type-module-in-indexhtml"><a class="header" href="#4-specify-type-module-in-indexhtml">4. Specify type module in index.html</a></h4>
<p>Here is the first difference.</p>
<p>Our index file at <code>www/html/index.html</code> look like this:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Wasm no NPM no Webpack&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

  &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Note the <b><code>type="module"</code></b></p>
<h4 id="5-import-with-file-extension-included-and-wrap-the-code-in-asyncawait-indexjs"><a class="header" href="#5-import-with-file-extension-included-and-wrap-the-code-in-asyncawait-indexjs">5. import with file extension included and Wrap the code in async/await index.js</a></h4>
<p>Second difference.</p>
<p>The js file <code>js/index.js</code> is modified to ES6 and look like this:</p>
<pre><code class="language-javascript">import init, { greet } from "../pkg/hello_world.js";

async function run() {
    const wasm = await init();

    greet('World');
}

run();
</code></pre>
<h4 id="6-build-with-wasm-pack"><a class="header" href="#6-build-with-wasm-pack">6. build with wasm-pack</a></h4>
<p>In your root directory, at the same level as Cargo.toml, build the project.</p>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg
</code></pre>
<ul>
<li><code> --target web</code> to specify nobundle and generate Es6 glue code</li>
<li><code>--no-typescript</code> we are not using TypeScript for these examples</li>
<li><code>--out-dir www/pkg</code> by default <code>pkg</code> is at the same level as the <code>src</code> directory.
Its cleaner to have all our web stuff in <code>www</code>.</li>
</ul>
<p>wasm-pack through wasm-bindgen-cli will generate the following in our <code>pkg</code> directory.</p>
<pre><code>└── pkg
    ├── hello_world_bg.wasm   # Wasm bytecode
    ├── hello_world.js        # JavaScript module to import (ESM)
    └── package.json
</code></pre>
<p>The output of <code>--target web</code> is included as an ES module.
Thats why we endup with an ES6 flavor of JavaScript.</p>
<h4 id="7-run-the-web-server-and-open-your-browser"><a class="header" href="#7-run-the-web-server-and-open-your-browser">7. Run the web server and open your browser</a></h4>
<p>You can use any file server, or follow along with <code>http</code> which, in this Guide, we installed after wasm-pack.</p>
<p>You can host locally the <code>www</code> directory with <code>http www</code>.
It defaults at  http://127.0.0.1:8000</p>
<p>You can pass the address and port number like this:</p>
<pre><code class="language-sh">http -a 127.0.0.1 -p 8080 www
</code></pre>
<p>Specifying our directory <code>www</code> will expose the following file structure to our server</p>
<pre><code>www
├── html
│   └── index.html
├── js
│   └── index.js
└── pkg
    ├── hello_world_bg.wasm
    ├── hello_world.js        
    └── package.json
</code></pre>
<!-- Validation - How should the reader verify the tutorial outcome? -->
<p>Open <code>index.html</code> in a browser by pointing at [http://127.0.0.1:8080/html/]</p>
<p><img src="../img/001.hello_world.png" alt="enjoy!" /></p>
<!-- Tearing down - Cleaning up resources -->
<h2 id="qa"><a class="header" href="#qa">Q&amp;A</a></h2>
<div class="alt-pre">01. How would you generate this clean <br/> file structure?
<svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg>
<pre >
.
├── Cargo.toml
├── src
│   └── lib.rs
└── www
    ├── html
    └── js
</pre>
<pre>
cargo new hello_world --lib
cd hello_world
mkdir -p www/html www/js
</pre>
</div>
<div class="alt-pre">02. In `wasm-pack build` What are these options for?
<svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg>
<pre >
--target web 
--no-typescript 
--out-dir www/pkg
</pre>
<pre>
- ` --target web` generate Es6 glue code.
- `--no-typescript` We're not using Ts.
- `--out-dir www/pkg` by default `pkg` is 
at the same level as the `src` directory and Cargo.toml file.
</pre>
</div>
<!-- Conclusion - Takeaways -->
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<p>The following is heavily indebted to MDN's <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_Wasm">Compiling from Rust to WebAssembly</a>{target="_blank"}</p>
<!--
For more details have a look at
[wasm-bindgen — how does it work?!](https://fitzgen.github.io/wasm-cg-wasm-bindgen/#1) by Nick Fitzgerald
-->
<h2 id="using-wasm-bindgen-to-communicate-between-rust-and-javascript"><a class="header" href="#using-wasm-bindgen-to-communicate-between-rust-and-javascript">Using wasm-bindgen to communicate between Rust and JavaScript</a></h2>
<h3 id="the-librs-file"><a class="header" href="#the-librs-file">The lib.rs file</a></h3>
<p><code>wasm-pack</code> uses <code>wasm-bindgen</code>, to provide a bridge between the types of JavaScript and Rust.
It allows JavaScript to call a Rust API with a string, or a Rust function to catch a JavaScript exception.</p>
<p>"The src/lib.rs file is the root of the Rust crate that we are compiling to WebAssembly.
It uses wasm-bindgen to interface with JavaScript.</p>
<p>In this example, it imports the window.alert JavaScript function,
and exports the greet Rust function, which alerts a greeting message."</p>
<!--
[rustwasm book:](https://rustwasm.github.io/docs/book/game-of-life/hello-world.html#wasm-game-of-lifesrclibrs){target="_blank"}
-->
<ul>
<li><code>extern</code> tells Rust that we want to call some externally defined functions.</li>
<li><code>#[wasm-bindgen]</code> on top of it knows how to find these functions for us in JavaScript.
in this case it will glue window.alert() from the browser's JavaScript to the Rust function header
that provides us a function signature Rust can understand.</li>
</ul>
<!--

[source](https://stackoverflow.com/questions/70437614/how-does-wasm-bindgen-determine-which-bindings-to-generate){target="_blank"}
In a nutshell, the #[wasm_bindgen] macro generates executable functions that describe the necessary bindings in Javascript inside some_binary.wasm. These functions are then executed by the wasm-bindgen CLI program to generate the Javascript bindings and a stripped WebAssembly module, i.e., some_binary_bg.wasm.
-->
<p>Whenever you want to call JavaScript functions,
you can add them to this file in this manner,
and wasm-bindgen takes care of setting everything up for you.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
// To crate to communicate between Rust and JavaScript
use wasm_bindgen::prelude::*;


// Calling external functions in JavaScript from Rust
#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
}

// Producing Rust functions that JavaScript can call 
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!("Hello, {}!", name)); //call alert function we asked for in the extern block above
}
<span class="boring">}</span></code></pre></pre>
<p>To expose public Rust function to the browsers' runtime  and allow calls from JavaScript,
use the  <code>#[wasm_bindgen]</code> attribute by placing it over the  <code>pub fn</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Producing Rust functions that JavaScript can call 
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
...
<span class="boring">}</span></code></pre></pre>
<p>It's the opposite of extern. We are exposing <code>greet</code> to Javascript so it can be used in "*.js" files.</p>
<p>This function is named greet, and takes one argument, a string (written &amp;str), name.
It then calls the alert function we asked for in the extern block above.</p>
<p>We use the <code>format!</code> macro to concatenate two string-literal and convert in to a String slices <code>&amp;</code></p>
<p>So the <code>alert</code> in <code>greet</code> calls the <code>alert</code> in the <code>extern</code> block,
which is glued to <code>window.alert</code> in the browser runtime.</p>
<p>For the curious, have a look at
<a href="https://rustwasm.github.io/wasm-bindgen/contributing/design/index.html" target="_bank">[Design of wasm-bindgen]</a></p>
<h2 id="indexhtml-and-indexjs-files"><a class="header" href="#indexhtml-and-indexjs-files">index.html and index.js files</a></h2>
<ol>
<li>index.html</li>
</ol>
<p><code>import</code> declarations in JavaScript can only be present in modules, so our <code>html</code> must specify that our <code>index.js</code>
file is a module.</p>
<p><code>&lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;</code></p>
<ol start="2">
<li>index.js</li>
</ol>
<!-- 
You may still come across unhelpful old information for our purpose. Information such as

```
// Note that a dynamic `import` statement here is required due to
// webpack/webpack#6615, but in theory `import { greet } from './pkg';`
// will work here one day as well!
const rust = import('./pkg');

rust
  .then(m => m.greet('World!'))
  .catch(console.error);
```

We are starting to see examples of the "modern" version 
of doing things but its still bundle specific like this: 

```JavaScript
import { greet } from './pkg';

greet('World');
```
-->
<p>As you recall, to specify that we are not using NPM and a bundler,
we used `wasm-pack --target web to compile our code,
Without NPM in mind. The build will produce ES6 code.</p>
<p><code>--out-dir www/pkg</code> is used to have wasm-pack output its glue code in <code>www/pkg</code>
because its nice to have all non Rust related  files in  a specific place such as <code>www</code>.</p>
<p>We are not using typescript for our examples so <code>--no-typescript</code> will
prevent the production of <code>*.ts</code> files in <code>pkg</code>.</p>
<p>We must used <code>ES module</code> import syntax, since we are working with Es6 code.
Hence importing modules in our javascript files must come with its extension <code>.js</code> in our <code>import</code> statement:</p>
<p><code>import ... from "../pkg/hello_world.js";</code></p>
<p>Where did this <code>hello_world</code> from?</p>
<aside>
You can change this name when building:
<pre><code class="language-sh">wasm-pack build --out-name &lt;OUT_NAME&gt; ...
</code></pre>
<p>The default is to use the package name</p>
</aside>
<p><code>wasm-pack</code> gets the name from our crate name as specified in Cargo.toml</p>
<pre><code class="language-toml">[package]
name = "hello_world"
...
</code></pre>
<p>and produces its JavaScript glue code with the same name.</p>
<h4 id="the-import-line"><a class="header" href="#the-import-line">The import line</a></h4>
<h5 id="init"><a class="header" href="#init">init()</a></h5>
<p>There is an initialization function <code>init</code> which
will "boot" the module and make it ready to use.</p>
<p>We must import this provided default <code>init</code> function.</p>
<pre><code class="language-js">import init, ... from "../pkg/hello_world.js";
</code></pre>
<p>The <code>init()</code> function will load the  <code>.wasm</code> binary that is in <code>www/pkg</code></p>
<h5 id="the-exported-rust-function"><a class="header" href="#the-exported-rust-function">The exported Rust function</a></h5>
<p>Next we import the <code>greet</code> function, which we made public in our Rust code
and accessible in our JavaScript with <code>#[wasm_bindgen]</code></p>
<pre><code class="language-js">import init, {greet} from "../pkg/hello_world.js";
</code></pre>
<h5 id="running-our-code"><a class="header" href="#running-our-code">Running our code</a></h5>
<p>Finally, we need to wrap the code in an <code>async/await</code> function.
Using async/await, <code>greet</code> will not be called until <code>init()</code> finishes loading the Wasm
that <code>greet("World")</code> needs to run.</p>
<p>Here again is the full listing:</p>
<pre><code class="language-javascript">import init, { greet } from "../pkg/hello_world.js";

async function run() {
    const wasm = await init();

    greet('World');
}

run();
</code></pre>
<hr />
<p><a href="./002.console_log.html">console_log <code>--&gt;</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../examples/wasm-bindgen_guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../examples/002.console_log.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../examples/wasm-bindgen_guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../examples/002.console_log.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
