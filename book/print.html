<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="struct_tech_tut.html"><strong aria-hidden="true">1.</strong> hide_me</a></li><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">2.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="wasm-bindgen_guide.html"><strong aria-hidden="true">3.</strong> from the wasm-bindgen guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="001.hello_world.html"><strong aria-hidden="true">3.1.</strong> hello_world</a></li><li class="chapter-item expanded "><a href="002.console_log.html"><strong aria-hidden="true">3.2.</strong> console_log</a></li><li class="chapter-item expanded "><a href="003.importing_non-browser_JS.html"><strong aria-hidden="true">3.3.</strong> importing_non-browser_JS</a></li><li class="chapter-item expanded "><a href="004.working_with_the_char_type.html"><strong aria-hidden="true">3.4.</strong> working_with_the_char_type</a></li><li class="chapter-item expanded "><a href="005.wasm-in-wasm.html"><strong aria-hidden="true">3.5.</strong> wasm-in-wasm</a></li><li class="chapter-item expanded "><a href="006.DOM.html"><strong aria-hidden="true">3.6.</strong> DOM</a></li><li class="chapter-item expanded "><a href="007.closures.html"><strong aria-hidden="true">3.7.</strong> closures</a></li><li class="chapter-item expanded "><a href="008.performance.html"><strong aria-hidden="true">3.8.</strong> performance</a></li><li class="chapter-item expanded "><a href="009.fetch.html"><strong aria-hidden="true">3.9.</strong> fetch</a></li><li class="chapter-item expanded "><a href="010.weather_report.html"><strong aria-hidden="true">3.10.</strong> weather_report</a></li><li class="chapter-item expanded "><a href="011.canvas.html"><strong aria-hidden="true">3.11.</strong> canvas</a></li><li class="chapter-item expanded "><a href="012.julia_set.html"><strong aria-hidden="true">3.12.</strong> julia_set</a></li><li class="chapter-item expanded "><a href="013.web_audio.html"><strong aria-hidden="true">3.13.</strong> web_audio</a></li><li class="chapter-item expanded "><a href="014.webgl.html"><strong aria-hidden="true">3.14.</strong> webgl</a></li><li class="chapter-item expanded "><a href="015.websockets.html"><strong aria-hidden="true">3.15.</strong> websockets</a></li><li class="chapter-item expanded "><a href="016.webrtc_datachannel.html"><strong aria-hidden="true">3.16.</strong> webrtc_datachannel</a></li><li class="chapter-item expanded "><a href="017.request-animation-frame.html"><strong aria-hidden="true">3.17.</strong> request-animation-frame</a></li><li class="chapter-item expanded "><a href="paint.html"><strong aria-hidden="true">3.18.</strong> paint</a></li><li class="chapter-item expanded "><a href="019.wasm-in-web-worker.html"><strong aria-hidden="true">3.19.</strong> wasm-in-web-worker</a></li><li class="chapter-item expanded "><a href="020.raytrace-parallel.html"><strong aria-hidden="true">3.20.</strong> raytrace-parallel</a></li><li class="chapter-item expanded "><a href="021.wasm-audio-worklet.html"><strong aria-hidden="true">3.21.</strong> wasm-audio-worklet</a></li><li class="chapter-item expanded "><a href="022.todomvc.html"><strong aria-hidden="true">3.22.</strong> todomvc</a></li></ol></li><li class="chapter-item expanded "><a href="canvas2d_game.html"><strong aria-hidden="true">4.</strong> Canvas 2d game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="dummy.html"><strong aria-hidden="true">4.1.</strong> dummy</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="structure-of-a-technical-tutorial"><a class="header" href="#structure-of-a-technical-tutorial">Structure of a technical tutorial</a></h1>
<p>source <a href="https://dev.to/dunithd/how-to-structure-a-perfect-technical-tutorial-21h9">https://dev.to/dunithd/how-to-structure-a-perfect-technical-tutorial-21h9</a></p>
<p><img src="./img/struct_tech_tut/001.tutorial_onepage_structure.png" alt="structure of a one page tutorial" /></p>
<h2 id="introduction---essential-summary-of-the-tutorial"><a class="header" href="#introduction---essential-summary-of-the-tutorial">Introduction - Essential summary of the tutorial</a></h2>
<p>Introduces the tutorial and briefly explains what to expect in the content.</p>
<p>The hook and the summary are two elements you can include in the introduction
to persuade the reader to continue reading the rest of the content.</p>
<ul>
<li>The hook: A few powerful sentences explaining why the reader should read the tutorial.
In most cases, this can be the problem you are trying to solve, summarized in 2–3 sentences.
The closer the hook gets to the reader's problem, the more readers continue reading.</li>
<li>Summary of the article (TLDR): What can the reader expect in the tutorial?
What's the outcome, and what are the takeaways?</li>
</ul>
<p><img src="./img/struct_tech_tut/002.tutorial_hook_summary.png" alt="hook &amp; summary" /></p>
<h2 id="overview---the-problem-you-are-trying-to-solve-with-the-tutorial"><a class="header" href="#overview---the-problem-you-are-trying-to-solve-with-the-tutorial">Overview - The problem you are trying to solve with the tutorial</a></h2>
<p>This is where you should describe two things in particular.</p>
<ul>
<li>Problem statement: What problem are you trying to solve with the tutorial?
What benefits does it provide? Spend a paragraph or two mentioning these points.</li>
<li>Solution architecture: How are you trying to solve the problems?
What's the high-level solution architecture would look like?
Mention the technology components you will use in the tutorial and highlight the data flow,
connectivity, and user interactions among them.</li>
</ul>
<p>Pick a fictitious use case and build your narrative around that.
For example, to build a data pipeline from a database to a data lake,
you can think of an online store use case.</p>
<p>Include visuals as much as possible in this section to provide more clarity to the reader.
Include a high-level solutions architecture diagram capturing the tutorial scenario.
That way, the reader can quickly capture what you are trying to do.</p>
<p><img src="./img/struct_tech_tut/003.tutorial_hook_summary_overview.png" alt="overview" /></p>
<h2 id="prerequisites---what-the-reader-must-have-before-getting-started"><a class="header" href="#prerequisites---what-the-reader-must-have-before-getting-started">Prerequisites - What the reader must have before getting started.</a></h2>
<p>You should mention what tools, technologies, and components the reader must have beforehand to complete the tutorial.
Use a bulleted list to mention them.</p>
<p>Furthermore, if certain tools are specific to a platform, highlight them as well.</p>
<p>Finished code repo:
Help readers by pushing the completed solution code into a public Git repo
and sharing its link</p>
<p><img src="./img/struct_tech_tut/004.tutorial_prereqs.png" alt="prerequisites" /></p>
<h2 id="lab---step-by-step-instructions"><a class="header" href="#lab---step-by-step-instructions">Lab - Step-by-step instructions</a></h2>
<p>This is where you provide step-by-step, Detailed guidance on each stage of the process or task.</p>
<p>Be sure to provide clear instructions in the order of their dependency.
Add screenshots and diagrams as needed - the more, the merrier.</p>
<p>After each instruction, provide the reader the means to verify whether they have executed
that properly.</p>
<p><img src="./img/struct_tech_tut/005.execution.png" alt="execution" /></p>
<h2 id="validation---how-should-the-reader-verify-the-tutorial-outcome"><a class="header" href="#validation---how-should-the-reader-verify-the-tutorial-outcome">Validation - How should the reader verify the tutorial outcome?</a></h2>
<p>Once the reader finishes following instructions, you should provide a way of verifying
the end-to-end solution.
You can include a screenshot or a visual portraying the final solution if the instructions
were followed correctly.</p>
<p>Known issues and challenges:
Sometimes, certain steps can't be completed due to technical challenges or limitations.
Therefore, state any known issues and inform the reader about possible workarounds.</p>
<h3 id="tearing-down---cleaning-up-resources"><a class="header" href="#tearing-down---cleaning-up-resources">Tearing down - Cleaning up resources</a></h3>
<p>Tearing down:
This is an optional step where you instruct the reader to destroy the environment
and clean things up.</p>
<h2 id="conclusion---takeaways"><a class="header" href="#conclusion---takeaways">Conclusion - Takeaways</a></h2>
<p>This is where we wrap things up.</p>
<p>Collecting the thoughts: Reiterate what you have accomplished in the tutorial. Spend the first paragraph of the conclusion wrapping things up.</p>
<p>Taking it to the next level: The tutorial might have shown a thin slice of a solution that addresses a simple problem. Suggest to the reader how to extend the solution to implement a real-world solution and take it to production. You don't have to be detailed here, but highlight a few potential steps necessary as a guideline.</p>
<p>Call to action: Dedicate the last paragraph to insert your CTA, driving satisfied readers to your <em>marketing funnel</em>.</p>
<p><img src="./img/struct_tech_tut/006.conclusion.png" alt="conclusion" /></p>
<hr />
<p>Summary</p>
<p>Technical tutorials can be packaged and presented in various formats,
including written articles, video tutorials, interactive online courses,
or a combination of these mediums.</p>
<p>You can use this post as a template to structure your tutorials,
regardless of the format they are presented.</p>
<p>As a rule of thumb, try to cut your content at the 2000 word mark because attention
span finite, and it isn't easy to navigate and follow a long document.
Use a tutorial series if the content goes beyond 2000 words.</p>
<hr />
<p>Conventions help shorten and clear up technical communication.</p>
<p><a href="https://conventionalcomments.org/">https://conventionalcomments.org/</a></p>
<p><a href="https://www.conventionalcommits.org/en/v1.0.0/">https://www.conventionalcommits.org/en/v1.0.0/</a></p>
<p><a href="https://martinfowler.com/articles/ship-show-ask.html">https://martinfowler.com/articles/ship-show-ask.html</a></p>
<p><a href="https://github.com/google/eng-practices/blob/57c895ad4b09c8941288c04e44a08797b76b4d4d/review/reviewer/standard.md#mentoring">Google Engineering Practices</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-bundle-wasm-by-example"><a class="header" href="#no-bundle-wasm-by-example">no-bundle Wasm by example</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>The Rust programming language is a great contender, if you want to:</p>
<ul>
<li>to build webassembly/JavaScript apps for the web or</li>
<li>target some specific module that need speeding, memory safety, or both.</li>
</ul>
<p>However, most Rust-wasm tutorials, lean heavily on "NPM and webpack", just to get a "hello world".</p>
<blockquote>
<p>The following pages brings under one location all those bits and pieces you want to know in order to understand and build wasm stuff with Rust.</p>
</blockquote>
<p>More specifically the intent is to address these wishes:</p>
<ul>
<li>Rust developers should be able to produce WebAssembly packages for use in JavaScript without requiring a Node.js development environment</li>
<li>JavaScript developers should be able to use WebAssembly without requiring a Rust development environment</li>
</ul>
<p>source: <a href="https://hacks.mozilla.org/2018/04/hello-wasm-pack/" target="_blank">[Hello wasm-pack!]</a></p>
<h2 id="objectives"><a class="header" href="#objectives">Objectives</a></h2>
<p>Webassembly is still a moving target and some tools and convenient crates make the experience more appealing.</p>
<ul>
<li>Learn how to transform most Rust/wasm tutorials into lean no-bloat rust-wasm with no-bundle.</li>
<li>Get familliar with the following tools and crates:
<ul>
<li><a href="https://rustwasm.github.io/wasm-pack/installer/" target="_blank">[wasm-pack]</a>,
<a href="https://rustwasm.github.io/docs/wasm-pack/introduction.html" target="_blank">[docs]</a></li>
<li><a href="https://github.com/rustwasm/wasm-bindgen" target="_blank">[wasm-bindgen]</a>,
<a href="https://rustwasm.github.io/docs/wasm-bindgen/" target="_blank">[docs]</a></li>
<li><a href="https://lib.rs/crates/js-sys" target="_blank">[js-sys]</a> &amp; <a href="https://lib.rs/crates/web-sys" target="_blank">[web-sys]</a>
<a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-in-wasm.html" target="_blank">[js-sys example]</a>,
<a href="https://rustwasm.github.io/wasm-bindgen/examples/dom.html" target="_blank">[web-sys examples]</a></li>
</ul>
</li>
</ul>
<h3 id="methodology"><a class="header" href="#methodology">Methodology</a></h3>
<p>We'll convert each examples from the <a href="https://rustwasm.github.io/docs/wasm-bindgen/" target="_blank">[wasm-bindgen guide]</a> to a no-bundle version.
For each example or demo:</p>
<ul>
<li>we'll get the example running.</li>
<li>we'll expose or highlight aspects of the code related to wasm-bindgen, wasm-pack or Rust.</li>
</ul>
<h4 id="0-get-wasm-pack-and-something-to-serve-our-website-locally"><a class="header" href="#0-get-wasm-pack-and-something-to-serve-our-website-locally">0. Get wasm-pack and something to serve our website locally</a></h4>
<p>Let's prepare our workspace, and setup our tools.</p>
<h5 id="01-install-wasm-pack"><a class="header" href="#01-install-wasm-pack">0.1 Install wasm-pack</a></h5>
<pre><code class="language-sh">cargo install wasm-pack
</code></pre>
<p>wasm-pack helps you build rust-generated WebAssembly packages
Its a useful convenience that is widely used by the Rust community.</p>
<p>If your interested see <a href="./wasm-pack_under_the_hood.html" target="_blank">[wasm-pack under the hood]</a></p>
<h5 id="02-install-a-local-tiny-static-file-server"><a class="header" href="#02-install-a-local-tiny-static-file-server">0.2 Install a local tiny static file server</a></h5>
<p>We need something to serve your website so we can test and see what we develop on our local machine.
If you don't have one installed you can use <code>H</code>ost <code>T</code>hese <code>T</code>hings <code>P</code>lease - a basic http server
for hosting a folder fast and simply <a href="https://github.com/thecoshman/http" target="_blank">[http]</a></p>
<pre><code class="language-bash">cargo install https
</code></pre>
<p>Note:</p>
<p><a href="https://trunkrs.dev/" target="_blank">[trunkrs.dev]</a> is getting traction in the Rust community
but its a much more ambitious tool and beyond our needs here.</p>
<h3 id="formula-for-converting-examples"><a class="header" href="#formula-for-converting-examples">Formula for Converting examples</a></h3>
<h4 id="seven-steps-to-hello-world"><a class="header" href="#seven-steps-to-hello-world">Seven steps to hello world</a></h4>
<ol>
<li>Set up your file structure</li>
<li>Edit Cargo.toml: Set the <em>crate-type</em> and add wasm-bindgen as a dependency.</li>
<li>Get the lib.rs code for hello_world</li>
<li>Specify type module in index.html</li>
<li>import with file extension included and Wrap the code in async/await index.js</li>
<li>build with wasm-pack</li>
<li>Run the web server and open your browser</li>
</ol>
<p>Let's see that in practice with the first example: <a href="./001_hello_world.html">wasm Hello world</a></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<!-- intro -->
<p><em>This is the "Hello, world!" example of #[wasm_bindgen] showing how to set up a project, export a function to JS, call it from JS, and then call the alert function in Rust.</em><br />
<a href="https://rustwasm.github.io/wasm-bindgen/examples/hello-world.html" target="_blank">[wasm-bindgen example]</a></p>
<!-- Introduction - Essential summary of the tutorial -->
<!-- Overview - The problem you are trying to solve with the tutorial -->
<!-- Prerequisites - What the reader must have before getting started. -->
<!-- Lab - Step-by-step instructions -->
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-examples-in-7-steps"><a class="header" href="#converting-examples-in-7-steps">Converting Examples in 7 steps</a></h2>
<h4 id="1-set-up-your-file-structure"><a class="header" href="#1-set-up-your-file-structure">1. Set up your file structure</a></h4>
<pre><code class="language-sh">cargo new hello_world --lib
cd hello_world
mkdir -p www/html www/js
</code></pre>
<p>You should have this file structure</p>
<pre><code class="language-sh">.
├── Cargo.toml
├── src
│   └── lib.rs
└── www
    ├── html
    └── js
</code></pre>
<h4 id="2-edit-cargotoml-set-the-crate-type-and-add-wasm-bindgen-as-a-dependency"><a class="header" href="#2-edit-cargotoml-set-the-crate-type-and-add-wasm-bindgen-as-a-dependency">2. Edit Cargo.toml: Set the crate-type and add wasm-bindgen as a dependency.</a></h4>
<p>In Cargo.toml, put <code>crate-type = ["cdylib"]</code> after <code>edition</code> entry.
And add wasm-bindgen as a dependency.</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasm-bindgen = "0.2.88"
</code></pre>
<p>Note:</p>
<p><code>wasm-bindgen-cli</code> will be installed
when we build with wasm-pack the first time,
so we are all good to go.</p>
<h4 id="3-get-the-librs-code-for-hello_world"><a class="header" href="#3-get-the-librs-code-for-hello_world">3. Get the lib.rs code for hello_world</a></h4>
<p>We'll cut and paste and modify the examples.
The point is to get used to convert code meant to be deployed
with NPM-Webpack ecosystem into a play vanilla no-bundle Rust wasm code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!("Hello, {}!", name));
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-specify-type-module-in-indexhtml"><a class="header" href="#4-specify-type-module-in-indexhtml">4. Specify type module in index.html</a></h4>
<p>Here is the first difference.</p>
<p>Our index file at <code>www/html/index.html</code> look like this:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Wasm no NPM no Webpack&lt;/title&gt;
  &lt;link rel="stylesheet" href="../css/styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;


  &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Note the <code>type="module"</code></p>
<h4 id="5-import-with-file-extension-included-and-wrap-the-code-in-asyncawait-indexjs"><a class="header" href="#5-import-with-file-extension-included-and-wrap-the-code-in-asyncawait-indexjs">5. import with file extension included and Wrap the code in async/await index.js</a></h4>
<p>Second difference.</p>
<p>Our full index.js is modified to look like this:</p>
<pre><code class="language-javascript">import init, { greet } from "../pkg/hello_world.js";

async function run() {
    const wasm = await init();

    greet('World');
}

run();
</code></pre>
<h4 id="6-build-with-wasm-pack"><a class="header" href="#6-build-with-wasm-pack">6. build with wasm-pack</a></h4>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg
</code></pre>
<ul>
<li><code> --target web</code> to specify nobundle and generate Es6 glue code</li>
<li><code>--no-typescript</code> we are not using TypeScript for these examples</li>
<li><code>--out-dir www/pkg</code> by default <code>pkg</code> is at the same level as the <code>src</code> directory.
Its cleaner to have all our web stuff in <code>www</code>.</li>
</ul>
<p>wasm-pack through wasm-bindgen-cli will generate the following in our <code>pkg</code> directory.</p>
<pre><code>└── pkg
    ├── hello_world_bg.wasm   # Wasm bytecode
    ├── hello_world.js        # JavaScript module to import (ESM)
    └── package.json
</code></pre>
<p>The output of <code>--target web</code> is included as an ES module.
Thats why we endup with an ES6 flavor of JavaScript.</p>
<h4 id="7-run-the-web-server-and-open-your-browser"><a class="header" href="#7-run-the-web-server-and-open-your-browser">7. Run the web server and open your browser</a></h4>
<p>You can use any file server, or follow along with <code>http</code> which we installed after wasm-pack.</p>
<p>You can host locally the <code>www</code> directory with <code>http www</code>.
It defaults at  http://127.0.0.1:8000</p>
<p>You can pass the address and port number like this:</p>
<pre><code class="language-sh">http -a 127.0.0.1 -p 8080 www
</code></pre>
<p>Specifying our directory <code>www</code> will expose the following file structure to our server</p>
<pre><code>www
├── html
│   └── index.html
├── js
│   └── index.js
└── pkg
    ├── hello_world_bg.wasm
    ├── hello_world.js        
    └── package.json
</code></pre>
<!-- Validation - How should the reader verify the tutorial outcome? -->
<p>Open <code>index.html</code> in a browser by pointing at [http://127.0.0.1:8080/html/]</p>
<p><img src="./pix/hello_world.png" alt="enjoy!" /></p>
<!-- Tearing down - Cleaning up resources -->
<h2 id="qa"><a class="header" href="#qa">Q&amp;A</a></h2>
<div class="alt-pre">How would you generate this clean <br/> file structure?
<svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg>
<pre >
.
├── Cargo.toml
├── src
│   └── lib.rs
└── www
    ├── html
    └── js
</pre>
<pre>
cargo new hello_world --lib
<p>cd hello_world</p>
<p>mkdir -p www/html www/js
</pre></p>
</div>
<div class="alt-pre">In `wasm-pack build` What are these options for?
<svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg>
<pre >
--target web 
--no-typescript 
--out-dir www/pkg
</pre>
<pre>
- ` --target web` generate Es6 glue code
- `--no-typescript` We're not using Ts
- `--out-dir www/pkg` by default `pkg` is 
at the same level as the `src` directory
</pre>
</div>
<!-- Conclusion - Takeaways -->
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<p>The following is heavily indebted to MDN's <a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_Wasm">Compiling from Rust to WebAssembly</a>{target="_blank"}</p>
<!--
For more details have a look at
[wasm-bindgen — how does it work?!](https://fitzgen.github.io/wasm-cg-wasm-bindgen/#1) by Nick Fitzgerald
-->
<h2 id="using-wasm-bindgen-to-communicate-between-rust-and-javascript"><a class="header" href="#using-wasm-bindgen-to-communicate-between-rust-and-javascript">Using wasm-bindgen to communicate between Rust and JavaScript</a></h2>
<h3 id="the-librs-file"><a class="header" href="#the-librs-file">The lib.rs file</a></h3>
<p><code>wasm-pack</code> uses <code>wasm-bindgen</code>, to provide a bridge between the types of JavaScript and Rust.
It allows JavaScript to call a Rust API with a string, or a Rust function to catch a JavaScript exception.</p>
<p>"The src/lib.rs file is the root of the Rust crate that we are compiling to WebAssembly.
It uses wasm-bindgen to interface with JavaScript.</p>
<p>In this example, it imports the window.alert JavaScript function,
and exports the greet Rust function, which alerts a greeting message."</p>
<!--
[rustwasm book:](https://rustwasm.github.io/docs/book/game-of-life/hello-world.html#wasm-game-of-lifesrclibrs){target="_blank"}
-->
<ul>
<li><code>extern</code> tells Rust that we want to call some externally defined functions.</li>
<li><code>#[wasm-bindgen]</code> on top of it knows how to find these functions for us in JavaScript.
in this case it will glue window.alert() from the browser's JavaScript to the Rust function header
that provides us a function signature Rust can understand.</li>
</ul>
<!--

[source](https://stackoverflow.com/questions/70437614/how-does-wasm-bindgen-determine-which-bindings-to-generate){target="_blank"}
In a nutshell, the #[wasm_bindgen] macro generates executable functions that describe the necessary bindings in Javascript inside some_binary.wasm. These functions are then executed by the wasm-bindgen CLI program to generate the Javascript bindings and a stripped WebAssembly module, i.e., some_binary_bg.wasm.
-->
<p>Whenever you want to call JavaScript functions,
you can add them to this file in this manner,
and wasm-bindgen takes care of setting everything up for you.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
// To crate to communicate between Rust and JavaScript
use wasm_bindgen::prelude::*;


// Calling external functions in JavaScript from Rust
#[wasm_bindgen]
extern "C" {
    fn alert(s: &amp;str);
}

// Producing Rust functions that JavaScript can call 
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!("Hello, {}!", name)); //call alert function we asked for in the extern block above
}
<span class="boring">}</span></code></pre></pre>
<p>To expose public Rust function to the browsers' runtime  and allow calls from JavaScript,
use the  <code>#[wasm_bindgen]</code> attribute by placing it over the  <code>pub fn</code> block.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Producing Rust functions that JavaScript can call 
#[wasm_bindgen]
pub fn greet(name: &amp;str) {
...
<span class="boring">}</span></code></pre></pre>
<p>It's the opposite of extern. We are exposing <code>greet</code> to Javascript so it can be used in "*.js" files.</p>
<p>This function is named greet, and takes one argument, a string (written &amp;str), name.
It then calls the alert function we asked for in the extern block above.</p>
<p>We use the <code>format!</code> macro to concatenate two string-literal and convert in to a String slices <code>&amp;</code></p>
<p>So the <code>alert</code> in <code>greet</code> calls the <code>alert</code> in the <code>extern</code> block,
which is glued to <code>window.alert</code> in the browser runtime.</p>
<p>For the curious, have a look at
<a href="https://rustwasm.github.io/wasm-bindgen/contributing/design/index.html">Design of wasm-bindgen</a>{target="_blank"}</p>
<h2 id="indexhtml-and-indexjs-files"><a class="header" href="#indexhtml-and-indexjs-files">index.html and index.js files</a></h2>
<ol>
<li>index.html</li>
</ol>
<p><code>import</code> declarations in JavaScript can only be present in modules, so our <code>html</code> must specify that our <code>index.js</code>
file is a module.</p>
<p><code>&lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;</code></p>
<ol start="2">
<li>index.js</li>
</ol>
<!-- 
You may still come across unhelpful old information for our purpose. Information such as

```
// Note that a dynamic `import` statement here is required due to
// webpack/webpack#6615, but in theory `import { greet } from './pkg';`
// will work here one day as well!
const rust = import('./pkg');

rust
  .then(m => m.greet('World!'))
  .catch(console.error);
```

We are starting to see examples of the "modern" version 
of doing things but its still bundle specific like this: 

```JavaScript
import { greet } from './pkg';

greet('World');
```
-->
<p>As you recall, to specify that we are not using NPM and a bundler,
we used `wasm-pack --target web to compile our code,
Without NPM in mind. The build will produce ES6 code.</p>
<p><code>--out-dir www/pkg</code> is used to have wasm-pack output its glue code in <code>www/pkg</code>
because its nice to have all non Rust related  files in  a specific place such as <code>www</code>.</p>
<p>We are not using typescript for our examples so <code>--no-typescript</code> will
prevent the production of <code>*.ts</code> files in <code>pkg</code>.</p>
<p>We must used <code>ES module</code> import syntax, since we are working with Es6 code.
Hence importing modules in our javascript files must come with its extension <code>.js</code> in our <code>import</code> statement:</p>
<p><code>import ... from "../pkg/hello_world.js";</code></p>
<p>Where did this <code>hello_world</code> from?</p>
<aside>
You can change this name when building:
<pre><code class="language-sh">wasm-pack build --out-name &lt;OUT_NAME&gt; ...
</code></pre>
<p>The default is to use the package name</p>
</aside>
<p><code>wasm-pack</code> gets the name from our crate name as specified in Cargo.toml</p>
<pre><code class="language-toml">[package]
name = "hello_world"
...
</code></pre>
<p>and produces its JavaScript glue code with the same name.</p>
<h4 id="the-import-line"><a class="header" href="#the-import-line">The import line</a></h4>
<h5 id="init"><a class="header" href="#init">init()</a></h5>
<p>There is an initialization function <code>init</code> which
will "boot" the module and make it ready to use.</p>
<p>We must import this provided default <code>init</code> function.</p>
<pre><code class="language-js">import init, ... from "../pkg/hello_world.js";
</code></pre>
<p>The <code>init()</code> function will load the  <code>.wasm</code> binary that is in <code>www/pkg</code></p>
<h5 id="the-exported-rust-function"><a class="header" href="#the-exported-rust-function">The exported Rust function</a></h5>
<p>Next we import the <code>greet</code> function, which we made public in our Rust code
and accessible in our JavaScript with <code>#[wasm_bindgen]</code></p>
<pre><code class="language-js">import init, {greet} from "../pkg/hello_world.js";
</code></pre>
<h5 id="running-our-code"><a class="header" href="#running-our-code">Running our code</a></h5>
<p>Finally, we need to wrap the code in an <code>async/await</code> function.
Using async/await, <code>greet</code> will not be called until <code>init()</code> finishes loading the Wasm
that <code>greet("World")</code> needs to run.</p>
<p>Here again is the full listing:</p>
<pre><code class="language-javascript">import init, { greet } from "../pkg/hello_world.js";

async function run() {
    const wasm = await init();

    greet('World');
}

run();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<div class="prevnext"><div class="button left">[<-- hello_world](./001_hello_world.html) </div>
<div class="button right">[Importing non-browser JS -->](./003_importing_non-browser_JS.html) </div></div>
<main>
<h1 id="consolelog"><a class="header" href="#consolelog">console.log</a></h1>
<p><em>This example shows off how to use console.log in a variety of ways, all the way from bare-bones usage to a println!-like macro with web_sys.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/console-log.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/console_log">wasm-bindgen example</a>{target="_blank"}</p>
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-examples-in-7-steps-1"><a class="header" href="#converting-examples-in-7-steps-1">Converting Examples in 7 steps</a></h2>
<h4 id="1-set-up-your-file-structure-1"><a class="header" href="#1-set-up-your-file-structure-1">1. Set up your file structure</a></h4>
<pre><code class="language-sh">cargo new console_log --lib
cd console_log
mkdir -p www/html www/js
</code></pre>
<h4 id="2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency"><a class="header" href="#2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency">2. Edit Cargo.toml, add crate-type and wasm-bindgen dependency</a></h4>
<pre><code class="language-toml">[package]
name = "console_log"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]


[dependencies]
wasm-bindgen = "0.2.88"

</code></pre>
<h4 id="3-get-the-code"><a class="header" href="#3-get-the-code">3. get the code</a></h4>
<p>Cut and paste the console-log example <a href="https://rustwasm.github.io/wasm-bindgen/examples/console-log.html">src/lib.rs</a>{target="_blank"}</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn run() {
    bare_bones();
    using_a_macro();
    using_web_sys();
}

// First up let's take a look of binding `console.log` manually, without the
// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations
// manually ourselves, and the correctness of our program relies on the
// correctness of these annotations!

#[wasm_bindgen]
extern "C" {
    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &amp;str, b: &amp;str);
}

fn bare_bones() {
    log("Hello from Rust!");
    log_u32(42);
    log_many("Logging", "many values!");
}

// Next let's define a macro that's like `println!`, only it works for
// `console.log`. Note that `println!` doesn't actually work on the wasm target
// because the standard library currently just eats all output. To get
// `println!`-like behavior in your app you'll likely want a macro like this.

macro_rules! console_log {
    // Note that this is using the `log` function imported above during
    // `bare_bones`
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

fn using_a_macro() {
    console_log!("Hello {}!", "world");
    console_log!("Let's print some numbers...");
    console_log!("1 + 3 = {}", 1 + 3);
}

// And finally, we don't even have to define the `log` function ourselves! The
// `web_sys` crate already has it defined for us.

fn using_web_sys() {
    use web_sys::console;

    console::log_1(&amp;"Hello using web-sys".into());

    let js: JsValue = 4.into();
    console::log_2(&amp;"Logging arbitrary values looks like".into(), &amp;js);
}

<span class="boring">}</span></code></pre></pre>
<p>Note:</p>
<p>Since <code>use web_sys::console;</code> brings into scope console from the web-sys crate we need to
declare it in our Cargo dependencies.</p>
<pre><code class="language-toml">...
[dependencies]
wasm-bindgen = "0.2.88"
web-sys = { version = "0.3.65", features = ['console'] }`
</code></pre>
<h4 id="4-create-the-index-file-at-wwwhtmlindexhtml"><a class="header" href="#4-create-the-index-file-at-wwwhtmlindexhtml">4. create the index file at <code>www/html/index.html</code>:</a></h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;nobundle: console_log&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


  &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</code></pre>
<h4 id="5-the-js-file"><a class="header" href="#5-the-js-file">5. The js file</a></h4>
<p>We could have written the file like this</p>
<pre><code class="language-javascript">import init, { run as run_me } from "../pkg/console_log.js";

async function run() {
    const wasm = await init();
    run_me();
}

run();
</code></pre>
<p>But because we used <code>#[wasm_bindgen(start)]</code> in <code>src/lib.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...
#[wasm_bindgen(start)]
fn run() {
    bare_bones();
    using_a_macro();
    using_web_sys();
}

...
<span class="boring">}</span></code></pre></pre>
<p>our js file can run directly</p>
<pre><code class="language-javascript">import init from "../pkg/console_log.js";

async function run() {
    const wasm = await init();

}

run();

</code></pre>
<h4 id="6-build-it"><a class="header" href="#6-build-it">6. build it</a></h4>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg
</code></pre>
<h4 id="7-serve-it"><a class="header" href="#7-serve-it">7. serve it</a></h4>
<pre><code class="language-sh">http www
</code></pre>
<p>Open the browser at http://127.0.0.1:8000/html/</p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p>and <code>ctrl-shift + I</code> to see the output in the browsers console log</p>
<p><img src="./pix/console_log.png" alt="Console log" /></p>
<h2 id="qa-1"><a class="header" href="#qa-1">Q&amp;A</a></h2>
<div class="alt-pre">How would you generate this clean <br/> file structure? 
<svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg>
<pre >
.
├── Cargo.toml
├── src
│   └── lib.rs
└── www
    ├── html
    └── js
</pre>
<pre>
cargo new hello_world --lib
<p>cd hello_world</p>
<p>mkdir -p www/html www/js
</pre></p>
</div>
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<h2 id="understand-the-code"><a class="header" href="#understand-the-code">Understand the Code</a></h2>
<h2 id="whats-next"><a class="header" href="#whats-next">What's next?</a></h2>
<p>There is nothing specific for nobundle in the <a href="https://rustwasm.github.io/wasm-bindgen/examples/add.html">Small wasm files</a>{target="_blank"} example so we'll pass it.</p>
<p>Now the <a href="https://rustwasm.github.io/wasm-bindgen/examples/without-a-bundler.html">Without a Bundler</a>{target="_blank"}  section makes sense.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/examples/synchronous-instantiation.html">Synchronous Instantiation</a>{target="_blank"} We'll stick with the default method, asynchronously initializing a module gets all our examples running.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm2js.html">Converting WebAssembly to JS</a>{target="_blank"}.
Nothing specific to nobundle, we pass.</p>
<p><span class="button"><a href="./index.html#list">Example list</a></span></p>
<div class="prevnext"><div class="button left">[<-- hello_world](./001_hello_world.html) </div>
<div class="button right">[Importing non-browser JS -->](./003_importing_non-browser_JS.html) </div></div>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);

let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<div class="prevnext"><div class="button left">[<-- console.log](./002_console_log.html)</div>
<div class="button right">[Working with the char type -->](./004_working_with_the_char_type.html)</div></div>
<main>
<h1 id="importing-non-browser-js"><a class="header" href="#importing-non-browser-js">Importing non-browser JS</a></h1>
<p><em>The <code>#[wasm_bindgen]</code> attribute can be used on <code>extern "C" { .. }</code> blocks to import functionality from JS. This is how the <code>js-sys</code> and the <code>web-sys</code> crates are built, but you can also use it in your own crate!</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/import-js.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/import_js">wasm-bindgen example</a>{target="_blank"}</p>
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-examples-in-7-steps-2"><a class="header" href="#converting-examples-in-7-steps-2">Converting Examples in 7 steps</a></h2>
<h4 id="1-make-the-file-structure"><a class="header" href="#1-make-the-file-structure">1. Make the file structure</a></h4>
<pre><code class="language-sh">cargo new import_js --lib
cd import_js
mkdir -p www/html www/js
</code></pre>
<h4 id="2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency-1"><a class="header" href="#2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency-1">2. Edit Cargo.toml, add crate-type and wasm-bindgen dependency</a></h4>
<pre><code class="language-toml">[package]
name = "import_js"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]


[dependencies]
wasm-bindgen = "0.2.88"

</code></pre>
<h4 id="3-get-the-code-1"><a class="header" href="#3-get-the-code-1">3. Get the code</a></h4>
<p><em>Cut and paste</em> the import-js example from github <a href="https://github.com/rustwasm/wasm-bindgen/blob/main/examples/import_js/crate/src/lib.rs">src/lib.rs</a></p>
<p>or the rust code in</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/examples/import-js.html">wasm-bindgen: import-js</a></p>
<p>Note:</p>
<pre><code>We need to modify `#[wasm_bindgen(module = "/defined-in-js.js")]`
as we made the commitment not to mix Rust and web code.
Our version will have `defined-in-js.js` in the `js` directory
with our `index.js` file. 
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen(module = "/www/js/defined-in-js.js")]
...
<span class="boring">}</span></code></pre></pre>
<p>So the full code is :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

use wasm_bindgen::prelude::*;

// our webserver's  root is www
#[wasm_bindgen(module = "/www/js/defined-in-js.js")]
extern "C" {
    fn name() -&gt; String;

    type MyClass;

    #[wasm_bindgen(constructor)]
    fn new() -&gt; MyClass;

    #[wasm_bindgen(method, getter)]
    fn number(this: &amp;MyClass) -&gt; u32;
    #[wasm_bindgen(method, setter)]
    fn set_number(this: &amp;MyClass, number: u32) -&gt; MyClass;
    #[wasm_bindgen(method)]
    fn render(this: &amp;MyClass) -&gt; String;
}

// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen(start)]
fn run() {
    log(&amp;format!("Hello from {}!", name())); // should output "Hello from Rust!"

    let x = MyClass::new();
    assert_eq!(x.number(), 42);
    x.set_number(10);
    log(&amp;x.render());
}
<span class="boring">}</span></code></pre></pre>
<h4 id="4-create-the-index-file-at-wwwhtmlindexhtml-1"><a class="header" href="#4-create-the-index-file-at-wwwhtmlindexhtml-1">4. create the index file at <code>www/html/index.html</code>:</a></h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Wasm no NPM no Webpack&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;


  &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h4 id="5-the-first-js-file-is-indexjs"><a class="header" href="#5-the-first-js-file-is-indexjs">5. The first js file is <code>index.js</code></a></h4>
<pre><code class="language-javascript">// www/js/index.js

import init from "../pkg/import_js.js";

async function run() {
    const wasm = await init();
}

run();
</code></pre>
<p>Our second javascript file <code>defined-in-js.js</code></p>
<pre><code class="language-js">// www/js/defined-in-js.js

export function name() {
    return 'Rust';
}

export class MyClass {
    constructor() {
        this._number = 42;
    }

    get number() {
        return this._number;
    }

    set number(n) {
        return this._number = n;
    }

    render() {
        return `My number is: ${this.number}`;
    }
}

</code></pre>
<h4 id="6-build-it-1"><a class="header" href="#6-build-it-1">6. build it</a></h4>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg
</code></pre>
<h4 id="7-serve-it-1"><a class="header" href="#7-serve-it-1">7. serve it</a></h4>
<pre><code class="language-sh">http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p>Open the browser at http://127.0.0.1:8000/html/<br />
and <code>ctrl-shift + I</code> to see the output in the browsers console log</p>
<p><img src="./pix/import_js.png" alt="importing non-browser Js" /></p>
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<h2 id="understand-the-code-1"><a class="header" href="#understand-the-code-1">Understand the Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// our webserver's  root is www
#[wasm_bindgen(module = "/www/js/defined-in-js.js")]
extern "C" {
    fn name() -&gt; String;

    type MyClass;

    #[wasm_bindgen(constructor)]
    fn new() -&gt; MyClass;

    #[wasm_bindgen(method, getter)]
    fn number(this: &amp;MyClass) -&gt; u32;
    #[wasm_bindgen(method, setter)]
    fn set_number(this: &amp;MyClass, number: u32) -&gt; MyClass;
    #[wasm_bindgen(method)]
    fn render(this: &amp;MyClass) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>We made the commitment not to mix Rust and web code.<br />
As such, <code>defined-in-js.js</code> is in the <code>js</code> directory with our <code>index.js</code>file.</p>
<p>The original code looks for this file next to the Cargo.toml file at the root directory with</p>
<pre><code>#[wasm_bindgen(module = "/defined-in-js.js")]
</code></pre>
<p>We point it to <code>www/js/</code> like this</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen(module = "/www/js/defined-in-js.js")]
extern "C" {
   ...
}
...
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p><code>module = "..."</code><br />
<a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/module.html">wasm-bindgen docs: attributes</a>{target="_blank"}</p>
</li>
<li>
<p>"<em>The #[wasm_bindgen] attribute can be used on extern "C" { .. } blocks to import functionality from JS.</em>"<br />
<a href="https://rustwasm.github.io/wasm-bindgen/examples/import-js.html">wasm-bindgen docs: Importing non-browser JS</a>{target="_blank"}</p>
</li>
<li>
<p><a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/constructor.html">wasm-bindgen docs: constructor</a>{target="_blank"}</p>
</li>
<li>
<p><a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/method.html">wasm-bindgen docs: method</a>{target="_blank"}</p>
</li>
<li>
<p><a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/getter-and-setter.html">wasm-bindgen docs: getter-and-setter</a>{target="_blank"}</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}
<span class="boring">}</span></code></pre></pre>
<p>Here we are making use of Javascript's console.log() method.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/js_namespace.html">wasm-bindgen docs: js_namespace</a>{target="_blank"}</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen(start)]
fn run() {
    log(&amp;format!("Hello from {}!", name())); // should output "Hello from Rust!"

    let x = MyClass::new();
    assert_eq!(x.number(), 42);
    x.set_number(10);
    log(&amp;x.render());
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The start function here should be started up automatically when the wasm module is loaded.<br />
<a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-rust-exports/start.html">wasm-bindgen docs: start</a>{target="_blank"}</li>
</ul>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's next?</a></h2>
<div class="prevnext"><div class="button left">[<-- console.log](./002_console_log.html)</div>
<div class="button right">[Working with the char type -->](./004_working_with_the_char_type.html)</div></div>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);

let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<div class="prevnext"><div class="button left">[<-- Importing non-browser JS ](./003_importing_non-browser_JS.html)</div>
<div class="button right">[js-sys: WebAssembly in WebAssembly -->](./005_wasm-in-wasm.html)</div></div>
<h1 id="working-with-the-char-type"><a class="header" href="#working-with-the-char-type">Working with the char type</a></h1>
<p><em>The #[wasm_bindgen] macro will convert the rust char type to a single code-point js string, and this example shows how to work with this.</em></p>
<aside>
Codepoint  
    An unique number for each Unicode character. It is rappresented by a collection of 1-6 uint8 elements for UTF-8, 1-2 uint16 elements for UTF-16, 1 uint32 element for UCS4, 1 uint8 element for ASCII, or something else.
[MDN web doc](https://devdoc.net/web/developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView.html#glossary_codepoint)
</aside>
<p><em>Opening this example should display a single counter with a random character for it's key and 0 for its count. You can click the + button to increase a counter's count. By clicking on the "add counter" button you should see a new counter added to the list with a different random character for it's key.</em></p>
<p><em>Under the hood javascript is choosing a random character from an Array of characters and passing that to the rust Counter struct's constructor so the character you are seeing on the page has made the full round trip from js to rust and back to js.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/char.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/char">wasm-bindgen example</a>{target="_blank"}</p>
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-examples-in-7-steps-3"><a class="header" href="#converting-examples-in-7-steps-3">Converting Examples in 7 steps</a></h2>
<h4 id="1-make-the-file-structure-1"><a class="header" href="#1-make-the-file-structure-1">1. Make the file structure</a></h4>
<pre><code class="language-sh">cargo new char --lib
cd char
mkdir -p www/html www/js
</code></pre>
<h4 id="2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency-2"><a class="header" href="#2-edit-cargotoml-add-crate-type-and-wasm-bindgen-dependency-2">2. Edit Cargo.toml, add crate-type and wasm-bindgen dependency</a></h4>
<pre><code class="language-toml">[package]
name = "char"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# See more keys and their definitions at 
# https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
wasm-bindgen = "0.2.88"
</code></pre>
<h4 id="3-get-the-code-2"><a class="header" href="#3-get-the-code-2">3. Get the code</a></h4>
<p><em>Cut and paste</em> the import-js example from github <a href="https://github.com/rustwasm/wasm-bindgen/blob/main/examples/char/src/lib.rs">src/lib.rs</a></p>
<p>or the rust code in</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/examples/char.html">wasm-bindgen: char</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;

// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[derive(Debug)]
#[wasm_bindgen]
pub struct Counter {
    key: char,
    count: i32,
}

#[wasm_bindgen]
impl Counter {
    pub fn new(key: char, count: i32) -&gt; Counter {
        log(&amp;format!("Counter::new({}, {})", key, count));
        Counter { key, count }
    }

    pub fn key(&amp;self) -&gt; char {
        log("Counter.key()");
        self.key
    }

    pub fn count(&amp;self) -&gt; i32 {
        log("Counter.count");
        self.count
    }

    pub fn increment(&amp;mut self) {
        log("Counter.increment");
        self.count += 1;
    }

    pub fn update_key(&amp;mut self, key: char) {
        self.key = key;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note we have the wasm_bindgen macro immediatly before our
struct declaration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
#[wasm_bindgen]
pub struct Counter {
    key: char,
    count: i32,
}
<span class="boring">}</span></code></pre></pre>
<p>Having it placed as in the official example  resulted in Counter not being pick up
and as a result not available in the glue code <code>pkg/char.js</code> which resulted in
<code>SyntaxError: ambiguous indirect export: Counter</code> in the browser.</p>
<pre><code>// DONT DO THIS

#[wasm_bindgen]    &lt;--- wrong place
#[derive(Debug)]
pub struct Counter {
    key: char,
    count: i32,
}
</code></pre>
<h4 id="4-create-the-index-file-at-wwwhtmlindexhtml-2"><a class="header" href="#4-create-the-index-file-at-wwwhtmlindexhtml-2">4. create the index file at <code>www/html/index.html</code>:</a></h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Counter nobundle&lt;/title&gt;
    &lt;link rel="stylesheet" href="../css/style.css"&gt;&lt;/head&gt;
&lt;body&gt;
   &lt;button id="add-counter" type="button"&gt;add counter&lt;/button&gt;
    &lt;div id="container"&gt;

    &lt;/div&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Let's put the stylesheet in <code>www/css/style.css</code></p>
<pre><code class="language-css">* {
    font-family: sans-serif;
    font-size: 16pt;
}
h1 {
    font-size: 18pt;
    font-weight: bold;
    margin: 0;
}
button {
    padding: 5px 10px;
    border: none;
    background: slategrey;
    margin: 10px auto;
    color: white;
}
body {
    width: 400px;
    margin: auto;
}
#container,
.counter {
    display: flex;
    flex-flow: column;
    justify-content: flex-start;
    align-items: flex-start;
    align-content: flex-start;
}
.counter {
    margin-bottom: 10px;
    background: steelblue;
    color: white;
    align-items: center;
    width: 100%;
}
.field {
    display: flex;
    flex-flow: row;
    justify-content: space-around;
    width: 100%;
}
</code></pre>
<h4 id="5-js-files"><a class="header" href="#5-js-files">5. js files</a></h4>
<h5 id="51-get-char-listjs"><a class="header" href="#51-get-char-listjs">5.1 Get <code>char-list.js</code></a></h5>
<p><em>Cut &amp; paste</em>  <a href="https://github.com/rustwasm/wasm-bindgen/blob/main/examples/char/chars-list.js">char-list</a>{target="_blank"} and save as <code>char-list.js</code> in <code>www/js</code></p>
<pre><code class="language-js">export let chars = [
    '!','#','$','%','&amp;','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7',
    '8','9',':',';','&lt;','=','&gt;','?','@','A','B',
    'C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X',
    'Y','Z','[',']','^','_','`','a','b','c',
    'd','e','f','g','h','i','j','k','l','m','n',
    'o','p','q','r','s','t','u','v','w','x','y',
    'z','{','|','}','~',' ','¡','¢','£','¤','¥',
    '¦','§','¨','©','ª','«','¬','®','¯','°',
    '±','²','³','´','µ','¶','·','¸','¹','º','»',
    '¼','½','¾','¿','À','Á','Â','Ã','Ä','Å','Æ',
    'Ç','È','É','Ê','Ë','Ì','Í','Î','Ï','Ð','Ñ',
    'Ò','Ó','Ô','Õ','Ö','×','Ø','Ù','Ú','Û','Ü',
    'Ý','Þ','ß','à','á','â','ã','ä','å','æ','ç',
    'è','é','ê','ë','ì','í','î','ï','ð','ñ','ò',
    'ó','ô','õ','ö','÷','ø','ù','ú','û','ü','ý',
    'þ','ÿ','Ā','ā','Ă','ă','Ą','ą','Ć','ć','Ĉ',
    'ĉ','Ċ','ċ','Č','č','Ď','ď','Đ','đ','Ē','ē',
    'Ĕ','ĕ','Ė','ė','Ę','ę','Ě','ě','Ĝ','ĝ','Ğ',
    'ğ','Ġ','ġ','Ģ','ģ','Ĥ','ĥ','Ħ','ħ','Ĩ','ĩ',
    'Ī','ī','Ĭ','ĭ','Į','į','İ','ı','Ĳ','ĳ','Ĵ',
    'ĵ','Ķ','ķ','ĸ','Ĺ','ĺ','Ļ','ļ','Ľ','ľ','Ŀ',
    'ŀ','Ł','ł','Ń','ń','Ņ','ņ','Ň','ň','ŉ','Ŋ',
    'ŋ','Ō','ō','Ŏ','ŏ','Ő','ő','Œ','œ','Ŕ','ŕ',
    'Ŗ','ŗ','Ř','ř','Ś','ś','Ŝ','ŝ','Ş','ş','Š',
    'š','Ţ','ţ','Ť','ť','Ŧ','ŧ','Ũ','ũ','Ū','ū',
    'Ŭ','ŭ','Ů','ů','Ű','ű','Ų','ų','Ŵ','ŵ','Ŷ',
    'ŷ','Ÿ','Ź','ź','Ż','ż','Ž','ž','ſ','ƀ','Ɓ',
    'Ƃ','ƃ','Ƅ','ƅ','Ɔ','Ƈ','ƈ','Ɖ','Ɗ','Ƌ','ƌ',
    'ƍ','Ǝ','Ə','Ɛ','Ƒ','ƒ','Ɠ','Ɣ','ƕ','Ɩ','Ɨ',
    'Ƙ','ƙ','ƚ','ƛ','Ɯ','Ɲ','ƞ','Ɵ','Ơ','ơ','Ƣ',
    'ƣ','Ƥ','ƥ','Ʀ','Ƨ','ƨ','Ʃ','ƪ','ƫ','Ƭ','ƭ',
    'Ʈ','Ư','ư','Ʊ','Ʋ','Ƴ','ƴ','Ƶ','ƶ','Ʒ','Ƹ',
    'ƹ','ƺ','ƻ','Ƽ','ƽ','ƾ','ƿ','ǀ','ǁ','ǂ','ǃ',
    'Ǆ','ǅ','ǆ','Ǉ','ǈ','ǉ','Ǌ','ǋ','ǌ','Ǎ','ǎ',
    'Ǐ','ǐ','Ǒ','ǒ','Ǔ','ǔ','Ǖ','ǖ','Ǘ','ǘ','Ǚ',
    'ǚ','Ǜ','ǜ','ǝ','Ǟ','ǟ','Ǡ','ǡ','Ǣ','ǣ','Ǥ',
    'ǥ','Ǧ','ǧ','Ǩ','ǩ','Ǫ','ǫ','Ǭ','ǭ','Ǯ','ǯ',
    'ǰ','Ǳ','ǲ','ǳ','Ǵ','ǵ','Ƕ','Ƿ','Ǹ','ǹ','Ǻ',
    'ǻ','Ǽ','ǽ','Ǿ','ǿ','Ȁ','ȁ','Ȃ','ȃ','Ȅ','ȅ',
    'Ȇ','ȇ','Ȉ','ȉ','Ȋ','ȋ','Ȍ','ȍ','Ȏ','ȏ','Ȑ',
    'ȑ','Ȓ','ȓ','Ȕ','ȕ','Ȗ','ȗ','Ș','ș','Ț','ț',
    'Ȝ','ȝ','Ȟ','ȟ','Ƞ','ȡ','Ȣ','ȣ','Ȥ','ȥ','Ȧ',
    'ȧ','Ȩ','ȩ','Ȫ','ȫ','Ȭ','ȭ','Ȯ','ȯ','Ȱ','ȱ',
    'Ȳ','ȳ','ȴ','ȵ','ȶ','ȷ','ȸ','ȹ','Ⱥ','Ȼ','ȼ',
    'Ƚ','Ⱦ','ȿ','ɀ','Ɂ','ɂ','Ƀ','Ʉ','Ʌ','Ɇ','ɇ',
    'Ɉ','ɉ','Ɋ','ɋ','Ɍ','ɍ','Ɏ','ɏ','ɐ','ɑ','ɒ',
    'ɓ','ɔ','ɕ','ɖ','ɗ','ɘ','ə','ɚ','ɛ','ɜ','ɝ',
    'ɞ','ɟ','ɠ','ɡ','ɢ','ɣ','ɤ','ɥ','ɦ','ɧ','ɨ',
    'ɩ','ɪ','ɫ','ɬ','ɭ','ɮ','ɯ','ɰ','ɱ','ɲ','ɳ',
    'ɴ','ɵ','ɶ','ɷ','ɸ','ɹ','ɺ','ɻ','ɼ','ɽ','ɾ',
    'ɿ','ʀ','ʁ','ʂ','ʃ','ʄ','ʅ','ʆ','ʇ','ʈ','ʉ',
    'ʊ','ʋ','ʌ','ʍ','ʎ','ʏ','ʐ','ʑ','ʒ','ʓ','ʔ',
    'ʕ','ʖ','ʗ','ʘ','ʙ','ʚ','ʛ','ʜ','ʝ','ʞ','ʟ',
    'ʠ','ʡ','ʢ','ʣ','ʤ','ʥ','ʦ','ʧ','ʨ','ʩ','ʪ',
    'ʫ','ʬ','ʭ','ʮ','ʯ','Ͳ','ͳ','ʹ','͵','Ͷ','ͷ',
    'ͺ','ͻ','ͼ','ͽ',';','Ϳ','΄','΅','Ά','·','Έ','Ή',
    'Ί','Ό','Ύ','Ώ',
    'ΐ','Α','Β','Γ','Δ','Ε','Ζ','Η','Θ','Ι','Κ',
    'Λ','Μ','Ν','Ξ','Ο','Π','Ρ','Σ','Τ','Υ','Φ',
    'Χ','Ψ','Ω','Ϊ','Ϋ','ά','έ','ή','ί','ΰ','α',
    'β','γ','δ','ε','ζ','η','θ','ι','κ','λ','μ',
    'ν','ξ','ο','π','ρ','ς','σ','τ','υ','φ','χ',
    'ψ','ω','ϊ','ϋ','ό','ύ','ώ','Ϗ','ϐ','ϑ','ϒ',
    'ϓ','ϔ','ϕ','ϖ','ϗ','Ϙ','ϙ','Ϛ','ϛ','Ϝ','ϝ',
    'Ϟ','ϟ','Ϡ','ϡ','Ϣ','ϣ','Ϥ','ϥ','Ϧ','ϧ','Ϩ',
    'ϩ','Ϫ','ϫ','Ϭ','ϭ','Ϯ','ϯ','ϰ','ϱ','ϲ','ϳ',
    'Օ','Ֆ','🕧','🕨','🕩','🕪','🕫','🕬','🕭','🕮',
    '🕯','🕰','🕱','🕲','🕳','🕴','🕵','🕶','🕷','🕸',
    '🕹','🕺','🕻','🕼','🕽','🕾','🕿','🖀','🖁','🖂',
    '🖃','🖄','🖅','🖆','🖇','🖈','🖉','🖊','🖋',
    '🖌','🖍','🖎','🖏','🖐','🖑','🖒','🖓','🖔','🖕',
    '🖖','🖗','🖘','🖙','🖚','🖛','🖜','🖝','🖞','🖟',
    '🖠','🖡','🖢','🖣','🖤','🖥','🖦','🖧','🖨','🖩',
    '🖪','🖫','🖬','🖭','🖮','🖯','🖰','🖱','🖲','🖳',
    '🖴','🖵','🖶','🖷','🖸','🖹','🖺','🖻','🖼','🖽',
    '🖾','🖿','🗀','🗁','🗂','🗃','🗄','🗅','🗆','🗇',
    '🗈','🗉','🗊','🗋','🗌','🗍','🗎','🗏','🗐','🗑','🗒',
    '🗓','🗔','🗕','🗖','🗗','🗘','🗙','🗚','🗛','🗜',
    '🗝','🗞','🗟','🗠','🗡','🗢','🗣','🗤','🗥','🗦',
    '🗧','🗨','🗩','🗪','🗫','🗬','🗭','🗮','🗯','🗰',
    '🗱','🗲','🗳','🗴','🗵','🗶','🗷','🗸','🗹','🗺',
    '🗻','🗼','🗽','🗾','🗿','😀'];


</code></pre>
<h5 id="52-indexjs-some-modification-required"><a class="header" href="#52-indexjs-some-modification-required">5.2 <code>index.js</code>: Some modification required</a></h5>
<p>Cut and paste <a href="https://raw.githubusercontent.com/rustwasm/wasm-bindgen/main/examples/char/index.js">the code</a>{target="_blank"}  to index.js.</p>
<h5 id="5521-imports"><a class="header" href="#5521-imports">5.5.2.1 imports</a></h5>
<p>This</p>
<pre><code>/* eslint-disable no-unused-vars */
import { chars } from './chars-list.js';
let imp = import('./pkg');
let mod;
</code></pre>
<p>becomes</p>
<pre><code class="language-js">// www/js/index.js
import init, { Counter }  from "../pkg/char.js";
import { chars } from './chars-list.js';
</code></pre>
<p>We don't need the <code>imp</code> as we get our wasm code from <code>init()</code>
and we don't need <code>mod</code> since we import <code>Counter</code> from the glue code.</p>
<p>Finally this:</p>
<pre><code class="language-js">let counters = [];
imp
  .then(wasm =&gt; {
      mod = wasm;
      addCounter();
      let b = document.getElementById('add-counter');
      if (!b) throw new Error('Unable to find #add-counter');
      b.addEventListener('click', ev =&gt; addCounter());
  })
  .catch(console.error);

</code></pre>
<p>becomes this</p>
<pre><code class="language-js">let counters = [];

async function run() {
    const wasm = await init();
           
    addCounter();
    let b = document.getElementById('add-counter');
    alert("b");
    if (!b) throw new Error('Unable to find #add-counter');
    b.addEventListener('click', ev =&gt; addCounter());
}//^-- async run

run();


</code></pre>
<p>And <code>Counter</code> is directly accessible by the other functions so we drop the <code>mod.Counter</code></p>
<pre><code class="language-js">function addCounter() {
    let ctr = Counter.new(randomChar(), 0);
</code></pre>
<p>So the final code is:</p>
<pre><code class="language-js">// www/js/index.js
import init, { Counter }  from "../pkg/char.js";
import { chars } from './chars-list.js';

let counters = [];

async function run() {
    const wasm = await init();
           
    addCounter();
    let b = document.getElementById('add-counter');
    alert("b");
    if (!b) throw new Error('Unable to find #add-counter');
    b.addEventListener('click', ev =&gt; addCounter());
    

}//^-- async run

run();


function addCounter() {
    let ctr = Counter.new(randomChar(), 0);
    counters.push(ctr);
    update();
    console.log("in addCounter");
}

function update() {
    let container = document.getElementById('container');
    if (!container) throw new Error('Unable to find #container in dom');
    while (container.hasChildNodes()) {
        if (container.lastChild.id == 'add-counter') break;
        container.removeChild(container.lastChild);
    }
    for (var i = 0; i &lt; counters.length; i++) {
        let counter = counters[i];
        container.appendChild(newCounter(counter.key(), counter.count(), ev =&gt; {
            counter.increment();
            update();
        }));
    }
}

function randomChar() {
    console.log('randomChar');
    let idx = Math.floor(Math.random() * (chars.length - 1));
    console.log('index', idx);
    let ret = chars.splice(idx, 1)[0];
    console.log('char', ret);
    return ret;
}

function newCounter(key, value, cb) {
    let container = document.createElement('div');
    container.setAttribute('class', 'counter');
    let title = document.createElement('h1');
    title.appendChild(document.createTextNode('Counter ' + key));
    container.appendChild(title);
    container.appendChild(newField('Count', value));
    let plus = document.createElement('button');
    plus.setAttribute('type', 'button');
    plus.setAttribute('class', 'plus-button');
    plus.appendChild(document.createTextNode('+'));
    plus.addEventListener('click', cb);
    container.appendChild(plus);
    return container;
}

function newField(key, value) {
    let ret = document.createElement('div');
    ret.setAttribute('class', 'field');
    let name = document.createElement('span');
    name.setAttribute('class', 'name');
    name.appendChild(document.createTextNode(key));
    ret.appendChild(name);
    let val = document.createElement('span');
    val.setAttribute('class', 'value');
    val.appendChild(document.createTextNode(value));
    ret.appendChild(val);
    return ret;
}
</code></pre>
<h4 id="6-build-it-2"><a class="header" href="#6-build-it-2">6. build it</a></h4>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg
</code></pre>
<h4 id="7-serve-it-2"><a class="header" href="#7-serve-it-2">7. serve it</a></h4>
<pre><code class="language-sh">http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p><img src="./pix/Counter.png" alt="working with the char type" /></p>
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<h2 id="understand-the-code-2"><a class="header" href="#understand-the-code-2">Understand the Code</a></h2>
<ul>
<li>#[wasm_bindgen]</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

#[wasm_bindgen]
pub struct Counter {
    key: char,
    count: i32,
}

#[wasm_bindgen]
impl Counter {
    pub fn new(key: char, count: i32) -&gt; Counter {
        log(&amp;format!("Counter::new({}, {})", key, count));
        Counter { key, count }
    }

...

<span class="boring">}</span></code></pre></pre>
<p><code>#[wasm_bindgen]</code> makes it possible to use a public Counter &amp; public new() from Javascript</p>
<pre><code class="language-js">// www/js/index.js

import init, { Counter }  from "../pkg/char.js";

// ...

function addCounter() {
    let ctr = Counter.new(randomChar(), 0);
    counters.push(ctr);
    update();
    console.log("in addCounter");
}
</code></pre>
<ul>
<li>async function</li>
</ul>
<p><em>The async function declaration creates a binding of a new async function to a given name. The await keyword is permitted within the function body, enabling asynchronous, promise-based behavior to be written in a cleaner style and avoiding the need to explicitly configure promise chains.</em> _ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">MDN: async function</a>{target="_blank"}</p>
<ul>
<li>await</li>
</ul>
<p><em>Async functions can contain zero or more await expressions. Await expressions make promise-returning functions behave as though they're synchronous by suspending execution until the returned promise is fulfilled or rejected. The resolved value of the promise is treated as the return value of the await expression.</em> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#description">MDN: async function</a>{target="_blank"}</p>
<pre><code class="language-js">async function run() {
    const wasm = await init();
           
    addCounter();
    let b = document.getElementById('add-counter');
    alert("b");
    if (!b) throw new Error('Unable to find #add-counter');
    b.addEventListener('click', ev =&gt; addCounter());
    

}//^-- async run

run();

</code></pre>
<ul>
<li>init()</li>
</ul>
<p><a href="https://github.com/rustwasm/wasm-bindgen/issues/1559">wasm-bindgen:  Support init function without parameters #1559</a></p>
<p>This issue opened by <em>ibaryshnikov</em> lead to our current <code>await init()</code></p>
<p><em>When used without a bundler, there is a need to call init with a .wasm file name:</em></p>
<pre><code class="language-js">await init('../pkg/my_project_bg.wasm');

//

await init('../pkg/another_project_bg.wasm');

</code></pre>
<p><em>Proposed Solution</em></p>
<p><em>Make it possible to use</em></p>
<pre><code class="language-js">await init();
</code></pre>
<p><em>which will default to path with generated .wasm file</em></p>
<p><em>@ibaryshnikov mentioned this issue Jun 7, 2019</em><br />
<em>added default module path inside init function when target is web #1579</em></p>
<p><em>alexcrichton closed this as completed in #1579 on Jun 10, 2019</em></p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's next?</a></h2>
<div class="prevnext"><div class="button left">[<-- Importing non-browser JS ](./003_importing_non-browser_JS.html)</div>
<div class="button right">[js-sys: WebAssembly in WebAssembly -->](./005_wasm-in-wasm.html)</div></div>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);

let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<div class="prevnext"><div class="button left">[<-- Working with the char type](./004_working_with_the_char_type.html)</div>
<div class="button right">[web-sys: DOM hello world -->](./006_DOM.html)</div></div>
<main>
<h1 id="js-sys-webassembly-in-webassembly"><a class="header" href="#js-sys-webassembly-in-webassembly">js-sys: WebAssembly in WebAssembly</a></h1>
<p><em>Using the js-sys crate we can instantiate WebAssembly modules from inside WebAssembly modules!</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-in-wasm.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/wasm-in-wasm">wasm-bindgen example</a>{target="_blank"}</p>
<blockquote>
<p>PART I. Make it run</p>
</blockquote>
<h2 id="converting-wasm-in-wasm-example"><a class="header" href="#converting-wasm-in-wasm-example">Converting wasm in wasm example</a></h2>
<h4 id="1-file-structure--crate-type"><a class="header" href="#1-file-structure--crate-type">1. file structure &amp; crate type</a></h4>
<pre><code class="language-sh">cargo new wasm-in-wasm --lib
cd wasm-in-wasm
cargo add wasm-bindgen
</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code></p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]
</code></pre>
<h4 id="2-make-the-wasm-file-to-be-used-by-wasm-in-wasm-later"><a class="header" href="#2-make-the-wasm-file-to-be-used-by-wasm-in-wasm-later">2. make the wasm file to be used by wasm-in-wasm later</a></h4>
<p>We want to use webassembly in our rust code.
First we shall generate a wasm file called <code>add.wasm</code></p>
<pre><code>// temporary src/lib.rs to generate our add.wasm file

use wasm_bindgen::prelude::wasm_bindgen;

#[wasm_bindgen]
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}
</code></pre>
<p>Build the wasm file with the out-name set to <code>add</code></p>
<pre><code class="language-sh">wasm-pack build --release --target web --out-name add --out-dir www/pkg
</code></pre>
<p>Since this wasm file is on the "server side", move it and rename from
<code>www/pkg/add_bg.wasm</code> to <code>src/add.wasm</code></p>
<p>and clean the project for our real code</p>
<pre><code class="language-sh">mv target/wasm32-unknown-unknown/release/add_bg.wasm ./src/add.wasm
cargo clean
'rm -fr www/pkg'
</code></pre>
<h4 id="3-html-and-js-files"><a class="header" href="#3-html-and-js-files">3. Html and Js files</a></h4>
<p>In <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;Using wasm in Rust&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Everything happens in rust/wasm &lt;br/ &gt;
    The developer console should have messages in it&lt;/p&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/wasm_in_wasm.js"

init();

/* 
    //async is handled directly in lib.rs
    async function run() {
        const wasm = await init();
    }

    run();
*/
</code></pre>
<p>Note:</p>
<p>The build outputs the file is <code>wasm_in_wasm.js</code> not <code>wasm-in-wasm.js</code><br />
we've seen that before (ie: the crate <code>wasm-bindgen</code> is used as <code>wasm_bindgen</code>)</p>
<h4 id="4-everything-happens-in-src"><a class="header" href="#4-everything-happens-in-src">4. Everything happens in src</a></h4>
<p>First, we need to add the two new crates <code>js-sys</code> and <code>wasm-bindgen-futures</code></p>
<pre><code class="language-sh">cargo add js-sys
cargo add wasm-bindgen-futures
</code></pre>
<p>we bring them into scope in <code>lib.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

use js_sys::{Function, Object, Reflect, WebAssembly};
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::{spawn_local, JsFuture};

// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &amp;str);
}

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

const WASM: &amp;[u8] = include_bytes!("add.wasm"); // path relative to lib.rs

async fn run_async() -&gt; Result&lt;(), JsValue&gt; {
    console_log!("instantiating a new wasm module directly");

    let a = JsFuture::from(WebAssembly::instantiate_buffer(WASM, &amp;Object::new())).await?;
    let b: WebAssembly::Instance = Reflect::get(&amp;a, &amp;"instance".into())?.dyn_into()?;

    let c = b.exports();

    let add = Reflect::get(c.as_ref(), &amp;"add".into())?
        .dyn_into::&lt;Function&gt;()
        .expect("add export wasn't a function");

    let three = add.call2(&amp;JsValue::undefined(), &amp;1.into(), &amp;2.into())?;
    console_log!("1 + 2 = {:?}", three);

    let mem = Reflect::get(c.as_ref(), &amp;"memory".into())?
        .dyn_into::&lt;WebAssembly::Memory&gt;()
        .expect("memory export wasn't a `WebAssembly.Memory`");
    console_log!("created module has {} pages of memory", mem.grow(0));
    console_log!("giving the module 4 more pages of memory");
    mem.grow(4);
    console_log!("now the module has {} pages of memory", mem.grow(0));

    Ok(())
}

#[wasm_bindgen(start)]
fn run() {
    spawn_local(async {
        run_async().await.unwrap_throw();
    });
}
<span class="boring">}</span></code></pre></pre>
<h4 id="5-build-and-serve"><a class="header" href="#5-build-and-serve">5. build and serve</a></h4>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p><img src="./pix/wasm_in_wasm.png" alt="wasm in wasm" /></p>
<hr />
<blockquote>
<p>PART II. Understand the Code</p>
</blockquote>
<h2 id="understand-the-code-3"><a class="header" href="#understand-the-code-3">Understand the Code</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use js_sys::{Function, Object, Reflect, WebAssembly};
<span class="boring">}</span></code></pre></pre>
<p><a href="https://docs.rs/js-sys/latest/js_sys/struct.Function.html">Struct js_sys::Function</a>{target="_blank"}</p>
<p><a href="https://docs.rs/js-sys/latest/js_sys/struct.Object.html">Struct js_sys::Object</a>{target="_blank"}</p>
<p><a href="https://docs.rs/js-sys/latest/js_sys/Reflect/index.html">Module js_sys::Reflect</a>{target="_blank"}</p>
<p><a href="https://docs.rs/js-sys/latest/js_sys/WebAssembly/index.html">Module js_sys::WebAssembly</a>{target="_blank"}</p>
<br/>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::wasm_bindgen;

#[wasm_bindgen]
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>The add.wasm would typically be used in a js file
since we made it available <code>#[wasm_bindgen]</code>.</p>
<p>But this time we are going to use it directly in our Rust code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const WASM: &amp;[u8] = include_bytes!("add.wasm"); // path relative to lib.rs
<span class="boring">}</span></code></pre></pre>
<p>Remember add.wasm is a binary.</p>
<pre><code>WebAssembly::instantiate_buffer(WASM, &amp;Object::new())
</code></pre>
<ul>
<li>JsFuture &amp; WebAssembly::instantiate_buffer</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let a = JsFuture::from(WebAssembly::instantiate_buffer(WASM, &amp;Object::new())).await?;
<span class="boring">}</span></code></pre></pre>
<p><a href="https://en.wikipedia.org/wiki/Futures_and_promises">wikipedia: Futures_and_promises</a>{target="_blank"}</p>
<ul>
<li>WebAssembly::Instance &amp; Reflect</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let b: WebAssembly::Instance = Reflect::get(&amp;a, &amp;"instance".into())?.dyn_into()?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>WebAssembly::Instance &amp; .exports()</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let c = b.exports();

<span class="boring">}</span></code></pre></pre>
<ul>
<li>dyn_into::&lt;&gt;</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let add = Reflect::get(c.as_ref(), &amp;"add".into())?
        .dyn_into::&lt;Function&gt;()
        .expect("add export wasn't a function");

<span class="boring">}</span></code></pre></pre>
<ul>
<li>Struct js_sys::Function &amp; call2()</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let three = add.call2(&amp;JsValue::undefined(), &amp;1.into(), &amp;2.into())?;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>js-sys WebAssembly::Memory &amp; .grow()</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mem = Reflect::get(c.as_ref(), &amp;"memory".into())?
        .dyn_into::&lt;WebAssembly::Memory&gt;()
        .expect("memory export wasn't a `WebAssembly.Memory`");
<span class="boring">}</span></code></pre></pre>
<p>grow memory</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    console_log!("created module has {} pages of memory", mem.grow(0));
    console_log!("giving the module 4 more pages of memory");

    mem.grow(4);

    console_log!("now the module has {} pages of memory", mem.grow(0));
<span class="boring">}</span></code></pre></pre>
<ul>
<li>spanw_local</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen(start)]
fn run() {
    spawn_local(async {
        run_async().await.unwrap_throw();
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="qa-2"><a class="header" href="#qa-2">Q&amp;A</a></h2>
<p><svg width="20px" height="30px" fill="#986a44" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="64px" height="64px" viewBox="0 0 344.339 344.339" xml:space="preserve" transform="rotate(270)" stroke="#986a44"><g id="SVGRepo_bgCarrier" stroke-width="0"></g><g id="SVGRepo_tracerCarrier" stroke-linecap="round" stroke-linejoin="round"></g><g id="SVGRepo_iconCarrier"> <g> <g> <g> <g> <path d="M149.535,323.088L0,173.554h94.299C106.192,41.217,220.448,21.251,288.212,21.251c32.12,0,55.166,4.378,56.127,4.549 l-1.279,13.382c-56.511,0-97.049,14.745-120.485,43.829c-26.518,32.903-23.636,75.735-21.647,90.537h98.137L149.535,323.088z"></path> </g> </g> </g> </g> </g></svg></p>
<hr />
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's next?</a></h2>
<div class="prevnext"><div class="button left">[<-- Working with the char type](./004_working_with_the_char_type.html)</div>
<div class="button right">[web-sys: DOM hello world -->](./006_DOM.html)</div></div>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
[`<--` js-sys: WebAssembly in WebAssembly](./005_wasm-in-wasm.html)
<hr />
<h2 id="web-sys-dom-hello-world"><a class="header" href="#web-sys-dom-hello-world">web-sys: DOM hello world</a></h2>
<p><em>Using web-sys we're able to interact with all the standard web platform methods, including those of the DOM! Here we take a look at a simple "Hello, world!" which manufactures a DOM element in Rust, customizes it, and then appends it to the page.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/dom.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/dom">wasm-bindgen DOM example</a>{target="_blank"}</p>
<h3 id="setup-the-project"><a class="header" href="#setup-the-project">setup the project</a></h3>
<pre><code class="language-sh">cargo new dom --lib
cd dom
mkdir -p www/js www/html
cargo add wasm-bindgen
</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code></p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;DOM nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/dom.js"

async function run() {
    const wasm = await init();
}

run();

</code></pre>
<h2 id="everything-happens-in-src"><a class="header" href="#everything-happens-in-src">Everything happens in src</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;

// Called by our JS entry point to run the example
#[wasm_bindgen(start)]
fn run() -&gt; Result&lt;(), JsValue&gt; {
    // Use `web_sys`'s global `window` function to get a handle on the global
    // window object.
    let window = web_sys::window().expect("no global `window` exists");
    let document = window.document().expect("should have a document on window");
    let body = document.body().expect("document should have a body");

    // Manufacture the element we're gonna append
    let val = document.create_element("p")?;
    val.set_text_content(Some("Hello from Rust!"));

    body.append_child(&amp;val)?;

    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<p>Note:</p>
<p>We need to add web-sys as a dependency and make some features available in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
wasm-bindgen = "0.2.88"

[dependencies.web-sys]
version = "0.3.65"
features = [
  'Document',
  'Element',
  'HtmlElement',
  'Node',
  'Window',
]
</code></pre>
<h2 id="build-and-serve"><a class="header" href="#build-and-serve">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's next?</a></h2>
<p>Next example: <a href="./007_closures.html">web-sys: Closures <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
[`<--` web-sys: DOM hello world](./006_DOM.html)
<hr />
<h2 id="web-sys-closures"><a class="header" href="#web-sys-closures">web-sys: Closures</a></h2>
<p><em>One of the features of #[wasm_bindgen] is that you can pass closures defined in Rust off to JS. This can be a bit tricky at times, though, so the example here shows how to interact with some standard web APIs with closures.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/closures.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h3 id="simple-example-using-the-gloo-crate"><a class="header" href="#simple-example-using-the-gloo-crate">Simple example using the gloo crate</a></h3>
<p>We start with our own example using a helper crate <code>gloo</code>, before diving into the harder official example</p>
<pre><code class="language-toml">...
[lib]
crate-type = ["cdylib"]

[dependencies]
gloo = "0.11.0"
js-sys = "0.3.67"
wasm-bindgen = "0.2.90"

[dependencies.web-sys]
version = "0.3.67"
features = [
  'Document',
  'Element',
  'HtmlElement',
  'HtmlParagraphElement',
  'HtmlSelectElement',
  'HtmlOptionsCollection',
  'Node',
  'Window',
  'console',
]
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use gloo::events::EventListener;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen(start)]
pub fn start() {
    select_country_on_click();
}

pub fn select_country_on_click() {
    let window = web_sys::window().expect("global window does not exists");
    let document = window.document().expect("expecting a document on window");
    let body = document
        .body()
        .expect("document expect to have have a body");

    let paragraph1= document
        .get_element_by_id("message")
        .unwrap()
        .dyn_into::&lt;web_sys::HtmlParagraphElement&gt;()
        .unwrap();
    let paragraph1_hello = paragraph1.clone();

    let select_country = document.get_element_by_id("countries")
        .unwrap()
        .dyn_into::&lt;web_sys::HtmlSelectElement&gt;()
        .unwrap();    
    let select_country_hello = select_country.clone();
    let mut index = 0;
    let on_click = EventListener::new(&amp;select_country, "click", move |_event| {
        web_sys::console::log_2(&amp;"Hello World Gloo :%s".into(), &amp;"Select country".into());
        
        index = select_country_hello.selected_index();
        paragraph_hello.set_text_content(Some(&amp;index.to_string()));
    });
    
    on_click.forget();
 
    body.append_child(&amp;paragraph).unwrap();
}

<span class="boring">}</span></code></pre></pre>
<pre><code class="language-javascript">import init from "../pkg/closures.js"

async function run() {
    const wasm = await init();
}

run();
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;Closures: nobundle&lt;/title&gt;
    &lt;style&gt;
        body {
            display: grid;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;select id="countries" name="countries"&gt;
  &lt;option value="KE"&gt;Kenya&lt;/option&gt;
  &lt;option value="MG"&gt;Madagascar&lt;/option&gt;
  &lt;option value="UY"&gt;Uruguay&lt;/option&gt;
  &lt;option value="UZ"&gt;Uzbekistan&lt;/option&gt;
  &lt;option value="VU"&gt;Vanuatu&lt;/option&gt;
  &lt;option value="ZM"&gt;Zambia&lt;/option&gt;
  &lt;option value="ZW"&gt;Zimbabwe&lt;/option&gt;
&lt;/select&gt;

      &lt;p id="message"&gt;&lt;/p&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="build-and-serve-1"><a class="header" href="#build-and-serve-1">build and serve</a></h3>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<p>And now the official example:</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/main/examples/closures">web-sys: Closures example</a>{target="_blank"}</p>
<h3 id="setup-the-project-1"><a class="header" href="#setup-the-project-1">setup the project</a></h3>
<pre><code class="language-sh">cargo new closures --lib
cd closures
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys web-sys
</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code></p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]
</code></pre>
<h3 id="web-sys-as-a-dependecy"><a class="header" href="#web-sys-as-a-dependecy">web-sys as a dependecy</a></h3>
<p>In Cargo.toml change the web-sys entry</p>
<pre><code class="language-toml">web-sys = "0.3.65"
</code></pre>
<p>to</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = "0.3.65"
features = [
  'CssStyleDeclaration',
  'Document',
  'Element',
  'HtmlElement',
  'Window',
]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;Closures: nobundle&lt;/title&gt;
    &lt;style&gt;
      #green-square {
        background: green;
        width: 200px;
        height: 200px;
        text-align: center;
        line-height: 200px;
        color: white;
      }
      #green-square span {
        display: inline-block;
        vertical-align: middle;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id='loading'&gt;
      Loading...
    &lt;/div&gt;
    &lt;div id='script' style='display:none'&gt;
      &lt;p&gt;
        The current time is:
        &lt;span id='current-time'&gt;...&lt;/span&gt;
      &lt;/p&gt;

      &lt;div id='green-square'&gt;
        &lt;span&gt;Click me!&lt;/span&gt;
      &lt;/div&gt;
      &lt;p&gt;
        You've clicked the green square
        &lt;span id='num-clicks'&gt;0&lt;/span&gt;
        times
      &lt;/p&gt;
    &lt;/div&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/closures.js"

async function run() {
    const wasm = await init();
}

run();
</code></pre>
<h2 id="everything-happens-in-src-1"><a class="header" href="#everything-happens-in-src-1">Everything happens in src</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use js_sys::{Array, Date};
use wasm_bindgen::prelude::*;
use web_sys::{Document, Element, HtmlElement, Window};

#[wasm_bindgen(start)]
fn run() -&gt; Result&lt;(), JsValue&gt; {
    let window = web_sys::window().expect("should have a window in this context");
    let document = window.document().expect("window should have a document");

    // One of the first interesting things we can do with closures is simply
    // access stack data in Rust!
    let array = Array::new();
    array.push(&amp;"Hello".into());
    array.push(&amp;1.into());
    let mut first_item = None;
    array.for_each(&amp;mut |obj, idx, _arr| match idx {
        0 =&gt; {
            assert_eq!(obj, "Hello");
            first_item = obj.as_string();
        }
        1 =&gt; assert_eq!(obj, 1),
        _ =&gt; panic!("unknown index: {}", idx),
    });
    assert_eq!(first_item, Some("Hello".to_string()));

    // Below are some more advanced usages of the `Closure` type for closures
    // that need to live beyond our function call.

    setup_clock(&amp;window, &amp;document)?;
    setup_clicker(&amp;document);

    // And now that our demo is ready to go let's switch things up so
    // everything is displayed and our loading prompt is hidden.
    document
        .get_element_by_id("loading")
        .expect("should have #loading on the page")
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect("#loading should be an `HtmlElement`")
        .style()
        .set_property("display", "none")?;
    document
        .get_element_by_id("script")
        .expect("should have #script on the page")
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect("#script should be an `HtmlElement`")
        .style()
        .set_property("display", "block")?;

    Ok(())
}

// Set up a clock on our page and update it each second to ensure it's got
// an accurate date.
//
// Note the usage of `Closure` here because the closure is "long lived",
// basically meaning it has to persist beyond the call to this one function.
// Also of note here is the `.as_ref().unchecked_ref()` chain, which is how
// you can extract `&amp;Function`, what `web-sys` expects, from a `Closure`
// which only hands you `&amp;JsValue` via `AsRef`.
fn setup_clock(window: &amp;Window, document: &amp;Document) -&gt; Result&lt;(), JsValue&gt; {
    let current_time = document
        .get_element_by_id("current-time")
        .expect("should have #current-time on the page");
    update_time(&amp;current_time);
    let a = Closure::&lt;dyn Fn()&gt;::new(move || update_time(&amp;current_time));
    window
        .set_interval_with_callback_and_timeout_and_arguments_0(a.as_ref().unchecked_ref(), 1000)?;
    fn update_time(current_time: &amp;Element) {
        current_time.set_inner_html(&amp;String::from(
            Date::new_0().to_locale_string("en-GB", &amp;JsValue::undefined()),
        ));
    }

    // The instance of `Closure` that we created will invalidate its
    // corresponding JS callback whenever it is dropped, so if we were to
    // normally return from `setup_clock` then our registered closure will
    // raise an exception when invoked.
    //
    // Normally we'd store the handle to later get dropped at an appropriate
    // time but for now we want it to be a global handler so we use the
    // `forget` method to drop it without invalidating the closure. Note that
    // this is leaking memory in Rust, so this should be done judiciously!
    a.forget();

    Ok(())
}

// We also want to count the number of times that our green square has been
// clicked. Our callback will update the `#num-clicks` div.
//
// This is pretty similar above, but showing how closures can also implement
// `FnMut()`.
fn setup_clicker(document: &amp;Document) {
    let num_clicks = document
        .get_element_by_id("num-clicks")
        .expect("should have #num-clicks on the page");
    let mut clicks = 0;
    let a = Closure::&lt;dyn FnMut()&gt;::new(move || {
        clicks += 1;
        num_clicks.set_inner_html(&amp;clicks.to_string());
    });
    document
        .get_element_by_id("green-square")
        .expect("should have #green-square on the page")
        .dyn_ref::&lt;HtmlElement&gt;()
        .expect("#green-square be an `HtmlElement`")
        .set_onclick(Some(a.as_ref().unchecked_ref()));

    // See comments in `setup_clock` above for why we use `a.forget()`.
    a.forget();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-2"><a class="header" href="#build-and-serve-2">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What's next?</a></h2>
<p>Next example: <a href="./008_performance.html">web-sys: performance.now <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance"><a class="header" href="#performance">performance<div class="navbar"><a class="openbtn" onclick="openNav()">☰</a></div></a></h1>
<main>
[`<--` web-sys: Closures](./007_closures.html)
<h2 id="web-sys-performancenow"><a class="header" href="#web-sys-performancenow">web-sys: performance.now</a></h2>
<p><em>Want to profile some Rust code in the browser? No problem! You can use the performance.now() API and friends to get timing information to see how long things take.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/performance.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/main/examples/performance">web-sys: performance.now</a>{target="_blank"}</p>
<h3 id="setup-the-project-2"><a class="header" href="#setup-the-project-2">setup the project</a></h3>
<pre><code class="language-sh">cargo new performance --lib
cd performance
mkdir -p www/js www/html
cargo add wasm-bindgen
</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code></p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;performance: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;The developer console should have timing log messages in it&lt;/p&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/performance.js"

async function run() {
    const wasm = await init();
}

run();
</code></pre>
<h2 id="everything-happens-in-src-2"><a class="header" href="#everything-happens-in-src-2">Everything happens in src</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use wasm_bindgen::prelude::*;

// lifted from the `console_log` example
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(a: &amp;str);
}

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

#[wasm_bindgen(start)]
fn run() {
    let window = web_sys::window().expect("should have a window in this context");
    let performance = window
        .performance()
        .expect("performance should be available");

    console_log!("the current time (in ms) is {}", performance.now());

    let start = perf_to_system(performance.timing().request_start());
    let end = perf_to_system(performance.timing().response_end());

    console_log!("request started at {}", humantime::format_rfc3339(start));
    console_log!("request ended at {}", humantime::format_rfc3339(end));
}

fn perf_to_system(amt: f64) -&gt; SystemTime {
    let secs = (amt as u64) / 1_000;
    let nanos = (((amt as u64) % 1_000) as u32) * 1_000_000;
    UNIX_EPOCH + Duration::new(secs, nanos)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="add-extra-dependencies"><a class="header" href="#add-extra-dependencies">Add extra dependencies</a></h2>
<pre><code class="language-toml">...

[dependencies]
wasm-bindgen = "0.2.88"
humantime = "2"

[dependencies.web-sys]
version = "0.3.4"
features = ['Window', 'Performance', 'PerformanceTiming']
</code></pre>
<h2 id="build-and-serve-3"><a class="header" href="#build-and-serve-3">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What's next?</a></h2>
<p>Next example: <a href="./009_fetch.html">The fetch API <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<p><a href="./008_performance.html"><code>&lt;--</code> web-sys: performance.now</a></p>
<h2 id="web-sys-the-fetch-api"><a class="header" href="#web-sys-the-fetch-api">web-sys: The fetch API</a></h2>
<p><em>This example uses the fetch API to make an HTTP request to the GitHub API and then parses the resulting JSON.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/fetch.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/fetch">web-sys: The fetch API</a>{target="_blank"}</p>
<h3 id="setup-the-project-3"><a class="header" href="#setup-the-project-3">setup the project</a></h3>
<pre><code class="language-sh">cargo new fetch --lib
cd fetch
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys wasm-bindgen-futures

</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code> &amp; <code>web-sys</code> features</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]

...


[dependencies.web-sys]
version = "0.3.66"
features = [
  'Headers',
  'Request',
  'RequestInit',
  'RequestMode',
  'Response',
  'Window',
]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;fetch: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;The developer console should have log messages in it&lt;/p&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">
import init, {run as rs_run} from "../pkg/fetch.js"

async function run() {
    const wasm = await init();
    const data = await rs_run("rustwasm/wasm-bindgen");
    console.log(data);

    console.log("The latest commit to the wasm-bindgen %s branch is:", data.name);
    console.log("%s, authored by %s &lt;%s&gt;", data.commit.sha, data.commit.commit.author.name, data.commit.commit.author.email);
}

run();

/*
const rust = import('./pkg');

rust
  .then(m =&gt; {
      return m.run("rustwasm/wasm-bindgen").then((data) =&gt; {
          console.log(data);

          console.log("The latest commit to the wasm-bindgen %s branch is:", data.name);
          console.log("%s, authored by %s &lt;%s&gt;", data.commit.sha, data.commit.commit.author.name, data.commit.commit.author.email);
      })
  })
  .catch(console.error);
*/
</code></pre>
<h2 id="rustwasm-side"><a class="header" href="#rustwasm-side">Rust/wasm side</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{Request, RequestInit, RequestMode, Response};

#[wasm_bindgen]
pub async fn run(repo: String) -&gt; Result&lt;JsValue, JsValue&gt; {
    let mut opts = RequestInit::new();
    opts.method("GET");
    opts.mode(RequestMode::Cors);

    let url = format!("https://api.github.com/repos/{}/branches/master", repo);

    let request = Request::new_with_str_and_init(&amp;url, &amp;opts)?;

    request
        .headers()
        .set("Accept", "application/vnd.github.v3+json")?;

    let window = web_sys::window().unwrap();
    let resp_value = JsFuture::from(window.fetch_with_request(&amp;request)).await?;

    // `resp_value` is a `Response` object.
    assert!(resp_value.is_instance_of::&lt;Response&gt;());
    let resp: Response = resp_value.dyn_into().unwrap();

    // Convert this other `Promise` into a rust `Future`.
    let json = JsFuture::from(resp.json()?).await?;

    // Send the JSON response back to JS.
    Ok(json)
}


<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-4"><a class="header" href="#build-and-serve-4">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What's next?</a></h2>
<p>Next example: <a href="./010.weather_report.html">web-sys: Weather report <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<p><a href="./009_fetch.html"><code>&lt;--</code> The fetch API</a></p>
<h2 id="web-sys-weather-report"><a class="header" href="#web-sys-weather-report">web-sys: Weather report</a></h2>
<p><em>This example makes an HTTP request to <a href="https://openweathermap.org/">OpenWeather API</a>{target="_blank"}, parses response in JSON and render UI from that JSON. It also shows the usage of spawn_local function for handling asynchronous tasks.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/weather_report.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/weather_report">web-sys: Weather report</a>{target="_blank"}</p>
<p><span style="color:red">The original example asks us to add our api key in get_response() before running this application.</span><br />
<b>Let's use <a href="https://open-meteo.com/">open-meteo</a> instead</b>. Open-Meteo is an open-source weather API and offers free access for non-commercial use. No API key required.</p>
<p>Our crate will be called meteo. we'll keep it simple to avoid <em>noise</em>
in our code that distract us from the aim of this example.</p>
<h3 id="setup-the-project-4"><a class="header" href="#setup-the-project-4">setup the project</a></h3>
<pre><code class="language-sh">cargo new meteo --lib
cd meteo
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys wasm-bindgen-futures

</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code> &amp; dependencies</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
gloo = "0.11.0"
json = "0.12.4"
reqwest = { version = "0.11.23", features = ["json"] } # reqwest with JSON parsing support
serde = { version = "1.0.193", features = ["derive"] }
wasm-bindgen = "0.2.90"
wasm-bindgen-futures = "0.4.40"


[dependencies.web-sys]
version = "0.3.67"
features = [
  'Document',
  'Element',
  'HtmlSelectElement',
  'Window',
]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;weather-report: meteo &lt;/title&gt;
    &lt;style&gt;
        body {
            display: grid;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/meteo.js"

async function run() {
    const wasm = await init().catch(console.error);
}

run();
</code></pre>
<h2 id="rustwasm-side-1"><a class="header" href="#rustwasm-side-1">Rust/wasm side</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;
use web_sys::{Document, Element,};
use gloo::events::EventListener;
use reqwest::Error; 
use wasm_bindgen_futures::spawn_local;


#[derive(Serialize, Deserialize)]
struct Current {
    interval: i32,       //900
    temperature_2m: f32, //20.0
    time: String,        //"2024-01-02T18:15"
    wind_speed_10m: f32, //21.3
}

#[derive(Serialize, Deserialize)]
struct CurrentUnits {
    interval: String,       //"seconds"
    temperature_2m: String, //"°C"
    time: String,           //"iso8601"
    wind_speed_10m: String, //"km/h"
}

#[derive(Serialize, Deserialize)]
struct OpenMeteo {
    current: Current,
    current_units: CurrentUnits,
    elevation: f32,                //1252.0
    generationtime_ms: f32,        //0.032067298889160156
    latitude: f32,                 //-18.875
    longitude: f32,                //47.5
    timezone: String,              //"GMT"
    timezone_abbreviation: String, //"GMT"
    utc_offset_seconds: u8,        //0
}

struct CountryData {
    name: String,
    capital: String,
    lat: f32,
    lon: f32
}

fn sample() -&gt; Vec&lt;CountryData&gt; {
       vec![
        CountryData { 
            name: "Madagascar".to_string(),
            capital: "Antananarivo".to_string(),
            lat: -18.91368, 
            lon: 47.53613
        },
        CountryData { 
            name: "Nepal".to_string(),
            capital: "Kathmandu".to_string(),
            lat: 27.70169, 
            lon: 85.3206
        },
        CountryData { 
            name: "Oman".to_string(),
            capital: "Muscat".to_string(),
            lat: 23.58413,
            lon: 58.40778
        },
        CountryData { 
            name: "Peru".to_string(),
            capital: "Lima".to_string(),
            lat: -12.04318,
            lon: -77.02824
        },
        CountryData { 
            name: "Quatar".to_string(),
            capital: "Doha".to_string(),
            lat: 25.28545,
            lon: 51.53096
        },
        CountryData { 
            name: "Rwanda".to_string(),
            capital: "Kigali".to_string(),
            lat: -1.94995, 
            lon: 30.05885
        },
        CountryData { 
            name: "Singapore".to_string(),
            capital: "Singapore".to_string(),
            lat: 1.28967, 
            lon: 103.85007
        },
     ]

}

// Called by our JS entry point to run the example
#[wasm_bindgen(start)]
async fn run() -&gt; Result&lt;(), JsValue&gt; {
    let country_list = sample();

    // Use `web_sys`'s global `window` function to get a handle on the global
    // window object.
    let window = web_sys::window().expect("no global `window` exists");
    let document = window.document().expect("should have a document on window");
    let body = document.body().expect("document should have a body");

    // mk City list
    let select_city_list = mkcity_list(&amp;document);
    body.append_child(&amp;select_city_list).unwrap();

    //
    let val = document.create_element("div")?;
    val.set_id("country_temp");
    body.append_child(&amp;val).unwrap();

    //
    let select_country = document.get_element_by_id("country_list")  // -&gt; Option&lt;Element&gt; 
        .unwrap()                                                    // We need to cast Element
        .dyn_into::&lt;web_sys::HtmlSelectElement&gt;()                    // into HtmlSelectElement
        .unwrap();    
    let select_country_hello = select_country.clone();
    let mut index: usize =0;
    
    let on_click = EventListener::new(&amp;select_country, "click", move |_event| {
        let val = val.clone();

        // detect selection        
        index = select_country_hello.selected_index() as usize;
        web_sys::console::log_2(&amp;"Country Index:%s".into(), &amp;index.into());
        // get selected country lat lon data
        let target_info = &amp;country_list[index];
        let target_capital = target_info.capital.clone();        

        // get city data
        let city_data = get_temp(target_info.lat, target_info.lon);//-18.879190, 47.507904).await?;

        spawn_local(async move {
            let target = city_data.await.unwrap();
            //display result
            val.set_inner_html(&amp;format!("{} \ntemp:{}{}", 
                            target_capital.as_str(),
                            target.current.temperature_2m,          
                            target.current_units.temperature_2m));
        });//^-- spawn

    }); //^-- on_click

    
    on_click.forget();

    Ok(())
}


fn mkcity_list(document: &amp;Document) -&gt; Element {
    let select_box = document.create_element("select").unwrap();
    select_box.set_id("country_list");
    let _ = document.body().unwrap().append_child(&amp;select_box);
    //
    for country in [
        "Madagascar",
        "Nepal",
        "Oman",
        "Peru",
        "Quatar",
        "Rwanda",
        "Singapore",
    ] {
        let option = document.create_element("option").unwrap();
        option.set_text_content(Some(country));
        let _ = select_box.append_child(&amp;option);
    }

    select_box
}



async fn get_temp(lat: f32, lon: f32) -&gt; Result&lt;OpenMeteo, Error&gt; { // 47.507905
    let url = format!("https://api.open-meteo.com/v1/forecast?latitude={lat}&amp;longitude={lon}&amp;current=temperature_2m,wind_speed_10m"); //latitude=-18.879190&amp;longitude=47.507904

    let selection =  reqwest::get(url).await?.json::&lt;OpenMeteo&gt;().await?;

    Ok(selection)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-5"><a class="header" href="#build-and-serve-5">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What's next?</a></h2>
<p>Next example: <a href="./011.canvas.html">web-sys: canvas hello world <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<p><a href="./010.weather_report.html"><code>&lt;--</code> web-sys: web-sys: Weather report</a></p>
<h2 id="web-sys-canvas-hello-world"><a class="header" href="#web-sys-canvas-hello-world">web-sys: canvas hello world</a></h2>
<p><em>Drawing a smiley face with the 2D canvas API. This is a port of part of this MDN tutorial to web-sys.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/2d-canvas.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/canvas">web-sys: canvas hello world</a></p>
<h3 id="setup-the-project-5"><a class="header" href="#setup-the-project-5">setup the project</a></h3>
<pre><code class="language-sh">cargo new canvas --lib
cd canvas
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys

</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code> &amp; <code>web-sys</code> features</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]

...


[dependencies.web-sys]
version = "0.3.66"
features = [
  'CanvasRenderingContext2d',
  'Document',
  'Element',
  'HtmlCanvasElement',
  'Window',
]

</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;canvas hello: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
        &lt;canvas id="canvas" height="150" width="150"&gt;&lt;/canvas&gt;

        &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init from "../pkg/canvas.js"

async function run() {
    const wasm = await init();
}

run();
</code></pre>
<h2 id="everything-happens-in-src-3"><a class="header" href="#everything-happens-in-src-3">Everything happens in src</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::f64;
use wasm_bindgen::prelude::*;

#[wasm_bindgen(start)]
fn start() {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id("canvas").unwrap();
    let canvas: web_sys::HtmlCanvasElement = canvas
        .dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()
        .map_err(|_| ())
        .unwrap();

    let context = canvas
        .get_context("2d")
        .unwrap()
        .unwrap()
        .dyn_into::&lt;web_sys::CanvasRenderingContext2d&gt;()
        .unwrap();

    context.begin_path();

    // Draw the outer circle.
    context
        .arc(75.0, 75.0, 50.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    // Draw the mouth.
    context.move_to(110.0, 75.0);
    context.arc(75.0, 75.0, 35.0, 0.0, f64::consts::PI).unwrap();

    // Draw the left eye.
    context.move_to(65.0, 65.0);
    context
        .arc(60.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    // Draw the right eye.
    context.move_to(95.0, 65.0);
    context
        .arc(90.0, 65.0, 5.0, 0.0, f64::consts::PI * 2.0)
        .unwrap();

    context.stroke();
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-6"><a class="header" href="#build-and-serve-6">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What's next?</a></h2>
<p>Next example: <a href="./012.julia_set.html">web-sys: canvas Julia set <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<p><a href="./011.canvas.html"><code>&lt;--</code> web-sys: canvas hello world</a></p>
<h2 id="web-sys-julia-set"><a class="header" href="#web-sys-julia-set">web-sys: Julia Set</a></h2>
<p><em>While not showing off a lot of web_sys API surface area, this example shows a neat fractal that you can make!</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/julia.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/julia_set">web-sys: Julia Set</a>{target="_blank"}</p>
<h3 id="setup-the-project-6"><a class="header" href="#setup-the-project-6">setup the project</a></h3>
<pre><code class="language-sh">cargo new julia_set --lib
cd julia_set
mkdir -p www/js www/html www/css
cargo add wasm-bindgen

</code></pre>
<p>Edit Cargo.toml</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2.89"

[dependencies.web-sys]
version = "0.3.66"
features = [
  'ImageData',
  'CanvasRenderingContext2d',
]
</code></pre>
<p>the index.html</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;meta name="viewport" content="initial-scale=1.0, user-scalable=no"/&gt;
    &lt;title&gt;Julia Set: nobundle&lt;/title&gt;
    &lt;link rel="stylesheet" href="../css/normalize.css"&gt;
    &lt;link rel="stylesheet" href="../css/skeleton.css"&gt;
    &lt;link rel="stylesheet" href="../css/style.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;main&gt;
      &lt;div class="controls"&gt;
        &lt;h1&gt;C =&lt;/h1&gt;
        &lt;div&gt;
          &lt;label for="real"&gt;real&lt;/label&gt;
          &lt;input type="number" name="real" id="real" value="-0.15" step="0.001"&gt;
        &lt;/div&gt;
        &lt;div&gt;
          &lt;label for="imaginary"&gt;imaginary&lt;/label&gt;
          &lt;input type="number" name="imaginary" id="imaginary" value="0.65" step="0.001"&gt;
        &lt;/div&gt;
        &lt;button class="button-primary" id="render"&gt;render&lt;/button&gt;
      &lt;/div&gt;
      &lt;canvas id="drawing" width="600" height="600"&gt;&lt;/canvas&gt;
    &lt;/main&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/rustwasm/wasm-bindgen/main/examples/julia_set/styles/normalize.css">download normalize.css</a>{target="_blank"}</li>
<li><a href="https://raw.githubusercontent.com/rustwasm/wasm-bindgen/main/examples/julia_set/styles/skeleton.css">download skeleton.css</a>{target="_blank"}</li>
<li><a href="https://raw.githubusercontent.com/rustwasm/wasm-bindgen/main/examples/julia_set/styles/style.css">download style.css</a>{target="_blank"}</li>
</ul>
<p>put them in <code>www/css</code></p>
<p>Next in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init, { draw } from "../pkg/julia_set.js"

async function run() {
    const wasm = await init().catch(console.error);
    console.log(wasm);
    const canvas = document.getElementById('drawing');
    const ctx = canvas.getContext('2d');
    const realInput = document.getElementById('real');
    const imaginaryInput = document.getElementById('imaginary');
    const renderBtn = document.getElementById('render');

    renderBtn.addEventListener('click', () =&gt; {
        const real = parseFloat(realInput.value) || 0;
        const imaginary = parseFloat(imaginaryInput.value) || 0;
        draw(ctx, 600, 600, real, imaginary);
    });

    draw(ctx, 600, 600, -0.15, 0.65);
}

run();
</code></pre>
<p>Finaly in Rust code in lib.rs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs

use std::ops::Add;
use wasm_bindgen::prelude::*;
use wasm_bindgen::Clamped;
use web_sys::{CanvasRenderingContext2d, ImageData};

#[wasm_bindgen]
pub fn draw(
    ctx: &amp;CanvasRenderingContext2d,
    width: u32,
    height: u32,
    real: f64,
    imaginary: f64,
) -&gt; Result&lt;(), JsValue&gt; {
    // The real workhorse of this algorithm, generating pixel data
    let c = Complex { real, imaginary };
    let data = get_julia_set(width, height, c);
    let data = ImageData::new_with_u8_clamped_array_and_sh(Clamped(&amp;data), width, height)?;
    ctx.put_image_data(&amp;data, 0.0, 0.0)
}

fn get_julia_set(width: u32, height: u32, c: Complex) -&gt; Vec&lt;u8&gt; {
    let mut data = Vec::new();

    let param_i = 1.5;
    let param_r = 1.5;
    let scale = 0.005;

    for x in 0..width {
        for y in 0..height {
            let z = Complex {
                real: y as f64 * scale - param_r,
                imaginary: x as f64 * scale - param_i,
            };
            let iter_index = get_iter_index(z, c);
            data.push((iter_index / 4) as u8);
            data.push((iter_index / 2) as u8);
            data.push(iter_index as u8);
            data.push(255);
        }
    }

    data
}

fn get_iter_index(z: Complex, c: Complex) -&gt; u32 {
    let mut iter_index: u32 = 0;
    let mut z = z;
    while iter_index &lt; 900 {
        if z.norm() &gt; 2.0 {
            break;
        }
        z = z.square() + c;
        iter_index += 1;
    }
    iter_index
}

#[derive(Clone, Copy, Debug)]
struct Complex {
    real: f64,
    imaginary: f64,
}

impl Complex {
    fn square(self) -&gt; Complex {
        let real = (self.real * self.real) - (self.imaginary * self.imaginary);
        let imaginary = 2.0 * self.real * self.imaginary;
        Complex { real, imaginary }
    }

    fn norm(&amp;self) -&gt; f64 {
        (self.real * self.real) + (self.imaginary * self.imaginary)
    }
}

impl Add&lt;Complex&gt; for Complex {
    type Output = Complex;

    fn add(self, rhs: Complex) -&gt; Complex {
        Complex {
            real: self.real + rhs.real,
            imaginary: self.imaginary + rhs.imaginary,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-7"><a class="header" href="#build-and-serve-7">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What's next?</a></h2>
<p>Next example: <a href="./013.web_audio.html">WebAudio <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<main>
<p><a href="./012.julia_set.html"><code>&lt;--</code> web-sys: Julia set</a></p>
<h2 id="web-sys-webaudio"><a class="header" href="#web-sys-webaudio">web-sys: webaudio</a></h2>
<p><em>This example creates an FM oscillator using the WebAudio API and web-sys.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/web-audio.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/main/examples/webaudio">web-sys: webaudio</a>{target="_blank"}</p>
<h3 id="setup-the-project-7"><a class="header" href="#setup-the-project-7">setup the project</a></h3>
<pre><code class="language-sh">cargo new webaudio --lib
cd webaudio
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys wasm-bindgen-futures

</code></pre>
<p>edit Cargo.toml to add <code>crate-type</code> &amp; <code>web-sys</code> features</p>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib",]

...


[dependencies.web-sys]
version = "0.3.66"
features = [
  'Headers',
  'Request',
  'RequestInit',
  'RequestMode',
  'Response',
  'Window',
]
</code></pre>
<p>in <code>www/html/index.html</code> we have</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;webaudio: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;input id="play" type="button" value="⏯"/&gt;
    (headphone users, please make sure your volume is not too loud!)

    &lt;div&gt;
        Primary frequency: &lt;input type="range" min="30" max="80" value="50" style="width: 400px" id="primary_input"/&gt;
    &lt;/div&gt;

    &lt;div&gt;
        Modulation frequency: &lt;input type="range" min="0" max="3" value="0" step="0.05"  style="width: 400px" id="fm_freq"/&gt;
    &lt;/div&gt;

    &lt;div&gt;
        Modulation amount: &lt;input type="range" min="0" max="3" value="0" step="0.05"  style="width: 400px" id="fm_amount"/&gt;
    &lt;/div&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>and in <code>www/js/index.js</code></p>
<pre><code class="language-js">import init, { FmOsc } from "../pkg/webaudio.js"

async function run_me() {
    const wasm = await init().catch(console.error);

    let fm = null;

    const play_button = document.getElementById("play");
    play_button.addEventListener("click", event =&gt; {
      if (fm === null) {
        fm = new FmOsc();
        fm.set_note(50);
        fm.set_fm_frequency(0);
        fm.set_fm_amount(0);
        fm.set_gain(0.8);
      } else {
        fm.free();
        fm = null;
      }
    });

    const primary_slider = document.getElementById("primary_input");
    primary_slider.addEventListener("input", event =&gt; {
      if (fm) {
        fm.set_note(parseInt(event.target.value));
      }
    });

    const fm_freq = document.getElementById("fm_freq");
    fm_freq.addEventListener("input", event =&gt; {
      if (fm) {
        fm.set_fm_frequency(parseFloat(event.target.value));
      }
    });

    const fm_amount = document.getElementById("fm_amount");
    fm_amount.addEventListener("input", event =&gt; {
      if (fm) {
        fm.set_fm_amount(parseFloat(event.target.value));
      }
    });
}//^-- run_me

run_me();
</code></pre>
<p>and the rust code in <code>lib.rs</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use wasm_bindgen::prelude::*;
use web_sys::{AudioContext, OscillatorType};

/// Converts a midi note to frequency
///
/// A midi note is an integer, generally in the range of 21 to 108
pub fn midi_to_freq(note: u8) -&gt; f32 {
    27.5 * 2f32.powf((note as f32 - 21.0) / 12.0)
}

#[wasm_bindgen]
pub struct FmOsc {
    ctx: AudioContext,
    /// The primary oscillator.  This will be the fundamental frequency
    primary: web_sys::OscillatorNode,

    /// Overall gain (volume) control
    gain: web_sys::GainNode,

    /// Amount of frequency modulation
    fm_gain: web_sys::GainNode,

    /// The oscillator that will modulate the primary oscillator's frequency
    fm_osc: web_sys::OscillatorNode,

    /// The ratio between the primary frequency and the fm_osc frequency.
    ///
    /// Generally fractional values like 1/2 or 1/4 sound best
    fm_freq_ratio: f32,

    fm_gain_ratio: f32,
}

impl Drop for FmOsc {
    fn drop(&amp;mut self) {
        let _ = self.ctx.close();
    }
}

#[wasm_bindgen]
impl FmOsc {
    #[wasm_bindgen(constructor)]
    pub fn new() -&gt; Result&lt;FmOsc, JsValue&gt; {
        let ctx = web_sys::AudioContext::new()?;

        // Create our web audio objects.
        let primary = ctx.create_oscillator()?;
        let fm_osc = ctx.create_oscillator()?;
        let gain = ctx.create_gain()?;
        let fm_gain = ctx.create_gain()?;

        // Some initial settings:
        primary.set_type(OscillatorType::Sine);
        primary.frequency().set_value(440.0); // A4 note
        gain.gain().set_value(0.0); // starts muted
        fm_gain.gain().set_value(0.0); // no initial frequency modulation
        fm_osc.set_type(OscillatorType::Sine);
        fm_osc.frequency().set_value(0.0);

        // Connect the nodes up!

        // The primary oscillator is routed through the gain node, so that
        // it can control the overall output volume.
        primary.connect_with_audio_node(&amp;gain)?;

        // Then connect the gain node to the AudioContext destination (aka
        // your speakers).
        gain.connect_with_audio_node(&amp;ctx.destination())?;

        // The FM oscillator is connected to its own gain node, so it can
        // control the amount of modulation.
        fm_osc.connect_with_audio_node(&amp;fm_gain)?;

        // Connect the FM oscillator to the frequency parameter of the main
        // oscillator, so that the FM node can modulate its frequency.
        fm_gain.connect_with_audio_param(&amp;primary.frequency())?;

        // Start the oscillators!
        primary.start()?;
        fm_osc.start()?;

        Ok(FmOsc {
            ctx,
            primary,
            gain,
            fm_gain,
            fm_osc,
            fm_freq_ratio: 0.0,
            fm_gain_ratio: 0.0,
        })
    }

    /// Sets the gain for this oscillator, between 0.0 and 1.0.
    #[wasm_bindgen]
    pub fn set_gain(&amp;self, mut gain: f32) {
        if gain &gt; 1.0 {
            gain = 1.0;
        }
        if gain &lt; 0.0 {
            gain = 0.0;
        }
        self.gain.gain().set_value(gain);
    }

    #[wasm_bindgen]
    pub fn set_primary_frequency(&amp;self, freq: f32) {
        self.primary.frequency().set_value(freq);

        // The frequency of the FM oscillator depends on the frequency of the
        // primary oscillator, so we update the frequency of both in this method.
        self.fm_osc.frequency().set_value(self.fm_freq_ratio * freq);
        self.fm_gain.gain().set_value(self.fm_gain_ratio * freq);
    }

    #[wasm_bindgen]
    pub fn set_note(&amp;self, note: u8) {
        let freq = midi_to_freq(note);
        self.set_primary_frequency(freq);
    }

    /// This should be between 0 and 1, though higher values are accepted.
    #[wasm_bindgen]
    pub fn set_fm_amount(&amp;mut self, amt: f32) {
        self.fm_gain_ratio = amt;

        self.fm_gain
            .gain()
            .set_value(self.fm_gain_ratio * self.primary.frequency().value());
    }

    /// This should be between 0 and 1, though higher values are accepted.
    #[wasm_bindgen]
    pub fn set_fm_frequency(&amp;mut self, amt: f32) {
        self.fm_freq_ratio = amt;
        self.fm_osc
            .frequency()
            .set_value(self.fm_freq_ratio * self.primary.frequency().value());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-8"><a class="header" href="#build-and-serve-8">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-11"><a class="header" href="#whats-next-11">What's next?</a></h2>
<p>Next example: <a href="./014.webgl.html">web-sys: webGl <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p><a href="./013.web_audio.html"><code>&lt;--</code> WebAudio</a></p>
<main>
## web-sys: WebGl 
<p><em>This example draws a triangle to the screen using the WebGL API.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/webgl.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/webgl">web-sys: WebGl</a>{target="_blank"}</p>
<h3 id="setup-the-project-8"><a class="header" href="#setup-the-project-8">setup the project</a></h3>
<pre><code class="language-sh">cargo new webgl --lib
cd webgl
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys

</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]


[dependencies]
js-sys = "0.3.66"
wasm-bindgen = "0.2.89"

[dependencies.web-sys]
version = "0.3.66"
features = [
  'Document',
  'Element',
  'HtmlCanvasElement',
  'WebGlBuffer',
  'WebGlVertexArrayObject',
  'WebGl2RenderingContext',
  'WebGlProgram',
  'WebGlShader',
  'Window',
]
</code></pre>
<h3 id="the-code"><a class="header" href="#the-code">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;webGl: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id="canvas" height="150" width="150"&gt;&lt;/canvas&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import init from "../pkg/webgl.js"

async function run() {
    const wasm = await init().catch(console.error);

}
run();
</code></pre>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;
use web_sys::{WebGl2RenderingContext, WebGlProgram, WebGlShader};

#[wasm_bindgen(start)]
fn start() -&gt; Result&lt;(), JsValue&gt; {
    let document = web_sys::window().unwrap().document().unwrap();
    let canvas = document.get_element_by_id("canvas").unwrap();
    let canvas: web_sys::HtmlCanvasElement = canvas.dyn_into::&lt;web_sys::HtmlCanvasElement&gt;()?;

    let context = canvas
        .get_context("webgl2")?
        .unwrap()
        .dyn_into::&lt;WebGl2RenderingContext&gt;()?;

    let vert_shader = compile_shader(
        &amp;context,
        WebGl2RenderingContext::VERTEX_SHADER,
        r##"#version 300 es
 
        in vec4 position;

        void main() {
        
            gl_Position = position;
        }
        "##,
    )?;

    let frag_shader = compile_shader(
        &amp;context,
        WebGl2RenderingContext::FRAGMENT_SHADER,
        r##"#version 300 es
    
        precision highp float;
        out vec4 outColor;
        
        void main() {
            outColor = vec4(1, 1, 1, 1);
        }
        "##,
    )?;
    let program = link_program(&amp;context, &amp;vert_shader, &amp;frag_shader)?;
    context.use_program(Some(&amp;program));

    let vertices: [f32; 9] = [-0.7, -0.7, 0.0, 0.7, -0.7, 0.0, 0.0, 0.7, 0.0];

    let position_attribute_location = context.get_attrib_location(&amp;program, "position");
    let buffer = context.create_buffer().ok_or("Failed to create buffer")?;
    context.bind_buffer(WebGl2RenderingContext::ARRAY_BUFFER, Some(&amp;buffer));

    // Note that `Float32Array::view` is somewhat dangerous (hence the
    // `unsafe`!). This is creating a raw view into our module's
    // `WebAssembly.Memory` buffer, but if we allocate more pages for ourself
    // (aka do a memory allocation in Rust) it'll cause the buffer to change,
    // causing the `Float32Array` to be invalid.
    //
    // As a result, after `Float32Array::view` we have to be very careful not to
    // do any memory allocations before it's dropped.
    unsafe {
        let positions_array_buf_view = js_sys::Float32Array::view(&amp;vertices);

        context.buffer_data_with_array_buffer_view(
            WebGl2RenderingContext::ARRAY_BUFFER,
            &amp;positions_array_buf_view,
            WebGl2RenderingContext::STATIC_DRAW,
        );
    }

    let vao = context
        .create_vertex_array()
        .ok_or("Could not create vertex array object")?;
    context.bind_vertex_array(Some(&amp;vao));

    context.vertex_attrib_pointer_with_i32(
        position_attribute_location as u32,
        3,
        WebGl2RenderingContext::FLOAT,
        false,
        0,
        0,
    );
    context.enable_vertex_attrib_array(position_attribute_location as u32);

    context.bind_vertex_array(Some(&amp;vao));

    let vert_count = (vertices.len() / 3) as i32;
    draw(&amp;context, vert_count);

    Ok(())
}

fn draw(context: &amp;WebGl2RenderingContext, vert_count: i32) {
    context.clear_color(0.0, 0.0, 0.0, 1.0);
    context.clear(WebGl2RenderingContext::COLOR_BUFFER_BIT);

    context.draw_arrays(WebGl2RenderingContext::TRIANGLES, 0, vert_count);
}

pub fn compile_shader(
    context: &amp;WebGl2RenderingContext,
    shader_type: u32,
    source: &amp;str,
) -&gt; Result&lt;WebGlShader, String&gt; {
    let shader = context
        .create_shader(shader_type)
        .ok_or_else(|| String::from("Unable to create shader object"))?;
    context.shader_source(&amp;shader, source);
    context.compile_shader(&amp;shader);

    if context
        .get_shader_parameter(&amp;shader, WebGl2RenderingContext::COMPILE_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(shader)
    } else {
        Err(context
            .get_shader_info_log(&amp;shader)
            .unwrap_or_else(|| String::from("Unknown error creating shader")))
    }
}

pub fn link_program(
    context: &amp;WebGl2RenderingContext,
    vert_shader: &amp;WebGlShader,
    frag_shader: &amp;WebGlShader,
) -&gt; Result&lt;WebGlProgram, String&gt; {
    let program = context
        .create_program()
        .ok_or_else(|| String::from("Unable to create shader object"))?;

    context.attach_shader(&amp;program, vert_shader);
    context.attach_shader(&amp;program, frag_shader);
    context.link_program(&amp;program);

    if context
        .get_program_parameter(&amp;program, WebGl2RenderingContext::LINK_STATUS)
        .as_bool()
        .unwrap_or(false)
    {
        Ok(program)
    } else {
        Err(context
            .get_program_info_log(&amp;program)
            .unwrap_or_else(|| String::from("Unknown error creating program object")))
    }
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-9"><a class="header" href="#build-and-serve-9">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-12"><a class="header" href="#whats-next-12">What's next?</a></h2>
<p>Next example: <a href="./015.websockets.html"> WebSockets <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p><a href="./014.webgl.html"><code>&lt;--</code> WebGl</a></p>
<main>
## web-sys: Web Sockets
<p><em>This example connects to an echo server on wss://echo.websocket.org, sends a ping message, and receives the response.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/websockets.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/websockets">web-sys: WebSockets</a>{target="_blank"}</p>
<p>It is already a no bundle example. :-)</p>
<h3 id="setup-the-project-9"><a class="header" href="#setup-the-project-9">setup the project</a></h3>
<pre><code class="language-sh">cargo new websockets --lib
cd websockets
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2.89"
js-sys = "0.3.66"

[dependencies.web-sys]
version = "0.3.66"
features = [
  "BinaryType",
  "Blob",
  "ErrorEvent",
  "FileReader",
  "MessageEvent",
  "ProgressEvent",
  "WebSocket",
]
</code></pre>
<h3 id="the-code-1"><a class="header" href="#the-code-1">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;web sockets: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import init from '../pkg/websockets.js';

window.addEventListener('load', async () =&gt; {
    await init('../pkg/websockets_bg.wasm');
});

/*
async function run() {
    const wasm = await init().catch(console.error);

}
run();
*/
</code></pre>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use wasm_bindgen::prelude::*;
use web_sys::{ErrorEvent, MessageEvent, WebSocket};

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
}

#[wasm_bindgen(start)]
fn start_websocket() -&gt; Result&lt;(), JsValue&gt; {
    // Connect to an echo server
    let ws = WebSocket::new("wss://echo.websocket.events")?;
    // For small binary messages, like CBOR, Arraybuffer is more efficient than Blob handling
    ws.set_binary_type(web_sys::BinaryType::Arraybuffer);
    // create callback
    let cloned_ws = ws.clone();
    let onmessage_callback = Closure::&lt;dyn FnMut(_)&gt;::new(move |e: MessageEvent| {
        // Handle difference Text/Binary,...
        if let Ok(abuf) = e.data().dyn_into::&lt;js_sys::ArrayBuffer&gt;() {
            console_log!("message event, received arraybuffer: {:?}", abuf);
            let array = js_sys::Uint8Array::new(&amp;abuf);
            let len = array.byte_length() as usize;
            console_log!("Arraybuffer received {}bytes: {:?}", len, array.to_vec());
            // here you can for example use Serde Deserialize decode the message
            // for demo purposes we switch back to Blob-type and send off another binary message
            cloned_ws.set_binary_type(web_sys::BinaryType::Blob);
            match cloned_ws.send_with_u8_array(&amp;[5, 6, 7, 8]) {
                Ok(_) =&gt; console_log!("binary message successfully sent"),
                Err(err) =&gt; console_log!("error sending message: {:?}", err),
            }
        } else if let Ok(blob) = e.data().dyn_into::&lt;web_sys::Blob&gt;() {
            console_log!("message event, received blob: {:?}", blob);
            // better alternative to juggling with FileReader is to use https://crates.io/crates/gloo-file
            let fr = web_sys::FileReader::new().unwrap();
            let fr_c = fr.clone();
            // create onLoadEnd callback
            let onloadend_cb = Closure::&lt;dyn FnMut(_)&gt;::new(move |_e: web_sys::ProgressEvent| {
                let array = js_sys::Uint8Array::new(&amp;fr_c.result().unwrap());
                let len = array.byte_length() as usize;
                console_log!("Blob received {}bytes: {:?}", len, array.to_vec());
                // here you can for example use the received image/png data
            });
            fr.set_onloadend(Some(onloadend_cb.as_ref().unchecked_ref()));
            fr.read_as_array_buffer(&amp;blob).expect("blob not readable");
            onloadend_cb.forget();
        } else if let Ok(txt) = e.data().dyn_into::&lt;js_sys::JsString&gt;() {
            console_log!("message event, received Text: {:?}", txt);
        } else {
            console_log!("message event, received Unknown: {:?}", e.data());
        }
    });
    // set message event handler on WebSocket
    ws.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
    // forget the callback to keep it alive
    onmessage_callback.forget();

    let onerror_callback = Closure::&lt;dyn FnMut(_)&gt;::new(move |e: ErrorEvent| {
        console_log!("error event: {:?}", e);
    });
    ws.set_onerror(Some(onerror_callback.as_ref().unchecked_ref()));
    onerror_callback.forget();

    let cloned_ws = ws.clone();
    let onopen_callback = Closure::&lt;dyn FnMut()&gt;::new(move || {
        console_log!("socket opened");
        match cloned_ws.send_with_str("ping") {
            Ok(_) =&gt; console_log!("message successfully sent"),
            Err(err) =&gt; console_log!("error sending message: {:?}", err),
        }
        // send off binary message
        match cloned_ws.send_with_u8_array(&amp;[0, 1, 2, 3]) {
            Ok(_) =&gt; console_log!("binary message successfully sent"),
            Err(err) =&gt; console_log!("error sending message: {:?}", err),
        }
    });
    ws.set_onopen(Some(onopen_callback.as_ref().unchecked_ref()));
    onopen_callback.forget();

    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-10"><a class="header" href="#build-and-serve-10">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-13"><a class="header" href="#whats-next-13">What's next?</a></h2>
<p>Next example: <a href="./016.webrtc_datachannel.html"> WebRTC DataChannel <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p><a href="./015.websockets.html"><code>&lt;--</code> Web Sockets</a></p>
<main>
## web-sys: WebRTC DataChannel
<p><em>This example connects to an echo server on wss://echo.websocket.org, sends a ping message, and receives the response.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/webrtc_datachannel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/webrtc_datachannel">web-sys: WebRTC DataChannel</a>{target="_blank"}</p>
<h3 id="setup-the-project-10"><a class="header" href="#setup-the-project-10">setup the project</a></h3>
<pre><code class="language-sh">cargo new webrtc_datachannel --lib
cd webrtc_datachannel
mkdir -p www/js www/html
cargo add wasm-bindgen js-sys wasm-bindgen-futures
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
js-sys = "0.3.66"
wasm-bindgen = "0.2.89"
wasm-bindgen-futures = "0.4.39"

[dependencies.web-sys]
version = "0.3.66"
features = [
  "MessageEvent",
  "RtcPeerConnection",
  "RtcSignalingState",
  "RtcSdpType",
  "RtcSessionDescriptionInit",
  "RtcPeerConnectionIceEvent",
  "RtcIceCandidate",
  "RtcDataChannel",
  "RtcDataChannelEvent",
]
</code></pre>
<h3 id="the-code-2"><a class="header" href="#the-code-2">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;WebRTC DataChannel: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Open DevTools and check the Console.&lt;/p&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import init from '../pkg/webrtc_datachannel.js';

window.addEventListener('load', async () =&gt; {
    await init('../pkg/webrtc_datachannel_bg.wasm');
});

/*
async function run() {
    const wasm = await init().catch(console.error);

}
run();
*/
</code></pre>
<p>Note with target web its <code>webrtc_datachannel_bg.wasm</code> we don't have a  <code>webrtc_datachannel.wasm</code> file</p>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use js_sys::Reflect;
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{
    MessageEvent, RtcDataChannelEvent, RtcPeerConnection, RtcPeerConnectionIceEvent, RtcSdpType,
    RtcSessionDescriptionInit,
};

macro_rules! console_log {
    ($($t:tt)*) =&gt; (log(&amp;format_args!($($t)*).to_string()))
}
macro_rules! console_warn {
    ($($t:tt)*) =&gt; (warn(&amp;format_args!($($t)*).to_string()))
}

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
    #[wasm_bindgen(js_namespace = console)]
    fn warn(s: &amp;str);
}

#[wasm_bindgen(start)]
async fn start() -&gt; Result&lt;(), JsValue&gt; {
    /*
     * Set up PeerConnections
     * pc1 &lt;=&gt; pc2
     *
     */
    let pc1 = RtcPeerConnection::new()?;
    console_log!("pc1 created: state {:?}", pc1.signaling_state());
    let pc2 = RtcPeerConnection::new()?;
    console_log!("pc2 created: state {:?}", pc2.signaling_state());

    /*
     * Create DataChannel on pc1 to negotiate
     * Message will be shown here after connection established
     *
     */
    let dc1 = pc1.create_data_channel("my-data-channel");
    console_log!("dc1 created: label {:?}", dc1.label());

    let dc1_clone = dc1.clone();
    let onmessage_callback = Closure::&lt;dyn FnMut(_)&gt;::new(move |ev: MessageEvent| {
        if let Some(message) = ev.data().as_string() {
            console_warn!("{:?}", message);
            dc1_clone.send_with_str("Pong from pc1.dc!").unwrap();
        }
    });
    dc1.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
    onmessage_callback.forget();

    /*
     * If negotiation has done, this closure will be called
     *
     */
    let ondatachannel_callback = Closure::&lt;dyn FnMut(_)&gt;::new(move |ev: RtcDataChannelEvent| {
        let dc2 = ev.channel();
        console_log!("pc2.ondatachannel!: {:?}", dc2.label());

        let onmessage_callback = Closure::&lt;dyn FnMut(_)&gt;::new(move |ev: MessageEvent| {
            if let Some(message) = ev.data().as_string() {
                console_warn!("{:?}", message);
            }
        });
        dc2.set_onmessage(Some(onmessage_callback.as_ref().unchecked_ref()));
        onmessage_callback.forget();

        let dc2_clone = dc2.clone();
        let onopen_callback = Closure::&lt;dyn FnMut()&gt;::new(move || {
            dc2_clone.send_with_str("Ping from pc2.dc!").unwrap();
        });
        dc2.set_onopen(Some(onopen_callback.as_ref().unchecked_ref()));
        onopen_callback.forget();
    });
    pc2.set_ondatachannel(Some(ondatachannel_callback.as_ref().unchecked_ref()));
    ondatachannel_callback.forget();

    /*
     * Handle ICE candidate each other
     *
     */
    let pc2_clone = pc2.clone();
    let onicecandidate_callback1 =
        Closure::&lt;dyn FnMut(_)&gt;::new(move |ev: RtcPeerConnectionIceEvent| {
            if let Some(candidate) = ev.candidate() {
                console_log!("pc1.onicecandidate: {:#?}", candidate.candidate());
                let _ = pc2_clone.add_ice_candidate_with_opt_rtc_ice_candidate(Some(&amp;candidate));
            }
        });
    pc1.set_onicecandidate(Some(onicecandidate_callback1.as_ref().unchecked_ref()));
    onicecandidate_callback1.forget();

    let pc1_clone = pc1.clone();
    let onicecandidate_callback2 =
        Closure::&lt;dyn FnMut(_)&gt;::new(move |ev: RtcPeerConnectionIceEvent| {
            if let Some(candidate) = ev.candidate() {
                console_log!("pc2.onicecandidate: {:#?}", candidate.candidate());
                let _ = pc1_clone.add_ice_candidate_with_opt_rtc_ice_candidate(Some(&amp;candidate));
            }
        });
    pc2.set_onicecandidate(Some(onicecandidate_callback2.as_ref().unchecked_ref()));
    onicecandidate_callback2.forget();

    /*
     * Send OFFER from pc1 to pc2
     *
     */
    let offer = JsFuture::from(pc1.create_offer()).await?;
    let offer_sdp = Reflect::get(&amp;offer, &amp;JsValue::from_str("sdp"))?
        .as_string()
        .unwrap();
    console_log!("pc1: offer {:?}", offer_sdp);

    let mut offer_obj = RtcSessionDescriptionInit::new(RtcSdpType::Offer);
    offer_obj.sdp(&amp;offer_sdp);
    let sld_promise = pc1.set_local_description(&amp;offer_obj);
    JsFuture::from(sld_promise).await?;
    console_log!("pc1: state {:?}", pc1.signaling_state());

    /*
     * Receive OFFER from pc1
     * Create and send ANSWER from pc2 to pc1
     *
     */
    let mut offer_obj = RtcSessionDescriptionInit::new(RtcSdpType::Offer);
    offer_obj.sdp(&amp;offer_sdp);
    let srd_promise = pc2.set_remote_description(&amp;offer_obj);
    JsFuture::from(srd_promise).await?;
    console_log!("pc2: state {:?}", pc2.signaling_state());

    let answer = JsFuture::from(pc2.create_answer()).await?;
    let answer_sdp = Reflect::get(&amp;answer, &amp;JsValue::from_str("sdp"))?
        .as_string()
        .unwrap();
    console_log!("pc2: answer {:?}", answer_sdp);

    let mut answer_obj = RtcSessionDescriptionInit::new(RtcSdpType::Answer);
    answer_obj.sdp(&amp;answer_sdp);
    let sld_promise = pc2.set_local_description(&amp;answer_obj);
    JsFuture::from(sld_promise).await?;
    console_log!("pc2: state {:?}", pc2.signaling_state());

    /*
     * Receive ANSWER from pc2
     *
     */
    let mut answer_obj = RtcSessionDescriptionInit::new(RtcSdpType::Answer);
    answer_obj.sdp(&amp;answer_sdp);
    let srd_promise = pc1.set_remote_description(&amp;answer_obj);
    JsFuture::from(srd_promise).await?;
    console_log!("pc1: state {:?}", pc1.signaling_state());

    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-11"><a class="header" href="#build-and-serve-11">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-14"><a class="header" href="#whats-next-14">What's next?</a></h2>
<p>Next example: <a href="./017.request-animation-frame.html"> web-sys: A requestAnimationFrame Loop <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p><a href="./016.webrtc_datachannel.html"><code>&lt;--</code> WebGl</a></p>
<main>
## web-sys: A requestAnimationFrame Loop
<p><em>This example connects to an echo server on wss://echo.websocket.org, sends a ping message, and receives the response.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/request-animation-frame.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/request-animation-frame">web-sys: request-animation-frame</a>{target="_blank"}</p>
<h3 id="setup-the-project-11"><a class="header" href="#setup-the-project-11">setup the project</a></h3>
<pre><code class="language-sh">cargo new request-animation-frame --lib
cd request-animation-frame
mkdir -p www/js www/html
cargo add wasm-bindgen
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
wasm-bindgen = "0.2.89"

[dependencies.web-sys]
version = "0.3.66"
features = [
  'Document',
  'Element',
  'HtmlElement',
  'Node',
  'Window',
]
</code></pre>
<h3 id="the-code-3"><a class="header" href="#the-code-3">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;request-animation-frame: nobundle&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;A greeting from rust looks like...&lt;/p&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">import init from '../pkg/request_animation_frame.js';

async function run() {
    const wasm = await init().catch(console.error);

}
run();
</code></pre>
<p>Note: <code>request-animation-frame</code> becomes <code>request_animation_frame</code></p>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;

fn window() -&gt; web_sys::Window {
    web_sys::window().expect("no global `window` exists")
}

fn request_animation_frame(f: &amp;Closure&lt;dyn FnMut()&gt;) {
    window()
        .request_animation_frame(f.as_ref().unchecked_ref())
        .expect("should register `requestAnimationFrame` OK");
}

fn document() -&gt; web_sys::Document {
    window()
        .document()
        .expect("should have a document on window")
}

fn body() -&gt; web_sys::HtmlElement {
    document().body().expect("document should have a body")
}

// This function is automatically invoked after the wasm module is instantiated.
#[wasm_bindgen(start)]
fn run() -&gt; Result&lt;(), JsValue&gt; {
    // Here we want to call `requestAnimationFrame` in a loop, but only a fixed
    // number of times. After it's done we want all our resources cleaned up. To
    // achieve this we're using an `Rc`. The `Rc` will eventually store the
    // closure we want to execute on each frame, but to start out it contains
    // `None`.
    //
    // After the `Rc` is made we'll actually create the closure, and the closure
    // will reference one of the `Rc` instances. The other `Rc` reference is
    // used to store the closure, request the first frame, and then is dropped
    // by this function.
    //
    // Inside the closure we've got a persistent `Rc` reference, which we use
    // for all future iterations of the loop
    let f = Rc::new(RefCell::new(None));
    let g = f.clone();

    let mut i = 0;
    *g.borrow_mut() = Some(Closure::new(move || {
        if i &gt; 300 {
            body().set_text_content(Some("All done!"));

            // Drop our handle to this closure so that it will get cleaned
            // up once we return.
            let _ = f.borrow_mut().take();
            return;
        }

        // Set the body's text content to how many times this
        // requestAnimationFrame callback has fired.
        i += 1;
        let text = format!("requestAnimationFrame has been called {} times.", i);
        body().set_text_content(Some(&amp;text));

        // Schedule ourself for another requestAnimationFrame callback.
        request_animation_frame(f.borrow().as_ref().unwrap());
    }));

    request_animation_frame(g.borrow().as_ref().unwrap());
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-12"><a class="header" href="#build-and-serve-12">build and serve</a></h2>
<pre><code class="language-sh">wasm-pack build --target web --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-15"><a class="header" href="#whats-next-15">What's next?</a></h2>
<p>Next example: <a href="./018.paint.html"> A Simple Paint Program <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><h1 id="paint"><a class="header" href="#paint">paint</a></h1>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p>Previous example: <a href="./018.paint.html"><code>&lt;--</code> A Simple Paint Program</a></p>
<main>
<h2 id="web-sys-wasm-in-web-worker"><a class="header" href="#web-sys-wasm-in-web-worker">web-sys: Wasm in Web Worker</a></h2>
<p><em>A simple example of parallel execution by spawning a web worker with web_sys, loading Wasm code in the web worker and interacting between the main thread and the worker.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-in-web-worker.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/wasm-in-web-worker">web-sys: Wasm in Web Worker</a>{target="_blank"}</p>
<h3 id="setup-the-project-12"><a class="header" href="#setup-the-project-12">setup the project</a></h3>
<pre><code class="language-sh">cargo new wasm-in-web-worker --lib
cd wasm-in-web-worker
mkdir -p www/js www/html www/css
cargo add wasm-bindgen console_error_panic_hook --optional
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">
[lib]
crate-type = ["cdylib"]

[dependencies]
console_error_panic_hook = { version = "0.1.7", optional = true }
wasm-bindgen = "0.2.89"

[dependencies.web-sys]
version = "0.3.66"
features = [
    'console',
    'Document',
    'HtmlElement',
    'HtmlInputElement',
    'MessageEvent',
    'Window',
    'Worker',
]
</code></pre>
<h3 id="the-code-4"><a class="header" href="#the-code-4">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;Wasm in Web Worker: nobundle&lt;/title&gt;
    &lt;link rel="stylesheet" href="../css/style.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
&lt;div id="wrapper"&gt;
        &lt;h1&gt;Main Thread/Wasm Web Worker Interaction&lt;/h1&gt;

        &lt;label for="inputNumber"&gt;Input &lt;b&gt;numbers&lt;/b&gt; to verify if it is odd or even&lt;/label&gt;

        &lt;input type="text" id="inputNumber" name="inputNumber"&gt;

        &lt;div id="resultField"&gt;&lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Make `wasm_bindgen` available for `index.js` --&gt;
    &lt;script src='../pkg/wasm_in_web_worker.js'&gt;&lt;/script&gt;
    
    &lt;!-- Note that there is no `type="module"` in the script tag --&gt;
    &lt;script src="../index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>style.css</li>
</ul>
<pre><code class="language-css">body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-family: "Century Gothic", CenturyGothic, Geneva, AppleGothic, sans-serif; 
    color: white;
    background-color: black;
}

#wrapper {
    width: 50%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#inputNumber {
    text-align: center;
}

#resultField {
    text-align: center;
    height: 1em;
    padding-top: 0.2em;
}
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">// We only need `startup` here which is the main entry point
// In theory, we could also use all other functions/struct types from Rust which we have bound with
// `#[wasm_bindgen]`

const {startup} = wasm_bindgen;

async function run_wasm() {
    // Load the wasm file by awaiting the Promise returned by `wasm_bindgen`
    // `wasm_bindgen` was imported in `index.html`
    await wasm_bindgen();

    console.log('index.js loaded');

    // Run main Wasm entry point
    // This will create a worker from within our Rust code compiled to Wasm
    startup();
}

run_wasm();

</code></pre>
<ul>
<li>worker.js</li>
</ul>
<pre><code class="language-js">// The worker has its own scope and no direct access to functions/objects of the
// global scope. We import the generated JS file to make `wasm_bindgen`
// available which we need to initialize our Wasm code.
importScripts('../pkg/wasm_in_web_worker.js');

console.log('Initializing worker')

// In the worker, we have a different struct that we want to use as in
// `index.js`.
const {NumberEval} = wasm_bindgen;

async function init_wasm_in_worker() {
    // Load the wasm file by awaiting the Promise returned by `wasm_bindgen`.
    await wasm_bindgen('../pkg/wasm_in_web_worker_bg.wasm');

    // Create a new object of the `NumberEval` struct.
    var num_eval = NumberEval.new();

    // Set callback to handle messages passed to the worker.
    self.onmessage = async event =&gt; {
        // By using methods of a struct as reaction to messages passed to the
        // worker, we can preserve our state between messages.
        var worker_result = num_eval.is_even(event.data);

        // Send response back to be handled by callback in main thread.
        self.postMessage(worker_result);
    };
};

init_wasm_in_worker();
</code></pre>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use web_sys::{console, HtmlElement, HtmlInputElement, MessageEvent, Worker};

/// A number evaluation struct
///
/// This struct will be the main object which responds to messages passed to the
/// worker. It stores the last number which it was passed to have a state. The
/// statefulness is not is not required in this example but should show how
/// larger, more complex scenarios with statefulness can be set up.
#[wasm_bindgen]
pub struct NumberEval {
    number: i32,
}

#[wasm_bindgen]
impl NumberEval {
    /// Create new instance.
    pub fn new() -&gt; NumberEval {
        NumberEval { number: 0 }
    }

    /// Check if a number is even and store it as last processed number.
    ///
    /// # Arguments
    ///
    /// * `number` - The number to be checked for being even/odd.
    pub fn is_even(&amp;mut self, number: i32) -&gt; bool {
        self.number = number;
        self.number % 2 == 0
    }

    /// Get last number that was checked - this method is added to work with
    /// statefulness.
    pub fn get_last_number(&amp;self) -&gt; i32 {
        self.number
    }
}

/// Run entry point for the main thread.
#[wasm_bindgen]
pub fn startup() {
    // Here, we create our worker. In a larger app, multiple callbacks should be
    // able to interact with the code in the worker. Therefore, we wrap it in
    // `Rc&lt;RefCell&gt;` following the interior mutability pattern. Here, it would
    // not be needed but we include the wrapping anyway as example.
    // to avoid cross-site error on the local server we don't use relative path `./js/workewr.js`
    let worker_handle = Rc::new(RefCell::new(Worker::new("http://localhost:8000/js/worker.js").unwrap()));
    console::log_1(&amp;"Created a new worker from within Wasm".into());

    // Pass the worker to the function which sets up the `oninput` callback.
    setup_input_oninput_callback(worker_handle);
}

fn setup_input_oninput_callback(worker: Rc&lt;RefCell&lt;web_sys::Worker&gt;&gt;) {
    let document = web_sys::window().unwrap().document().unwrap();

    // If our `onmessage` callback should stay valid after exiting from the
    // `oninput` closure scope, we need to either forget it (so it is not
    // destroyed) or store it somewhere. To avoid leaking memory every time we
    // want to receive a response from the worker, we move a handle into the
    // `oninput` closure to which we will always attach the last `onmessage`
    // callback. The initial value will not be used and we silence the warning.
    #[allow(unused_assignments)]
    let mut persistent_callback_handle = get_on_msg_callback();

    let callback = Closure::new(move || {
        console::log_1(&amp;"oninput callback triggered".into());
        let document = web_sys::window().unwrap().document().unwrap();

        let input_field = document
            .get_element_by_id("inputNumber")
            .expect("#inputNumber should exist");
        let input_field = input_field
            .dyn_ref::&lt;HtmlInputElement&gt;()
            .expect("#inputNumber should be a HtmlInputElement");

        // If the value in the field can be parsed to a `i32`, send it to the
        // worker. Otherwise clear the result field.
        match input_field.value().parse::&lt;i32&gt;() {
            Ok(number) =&gt; {
                // Access worker behind shared handle, following the interior
                // mutability pattern.
                let worker_handle = &amp;*worker.borrow();
                let _ = worker_handle.post_message(&amp;number.into());
                persistent_callback_handle = get_on_msg_callback();

                // Since the worker returns the message asynchronously, we
                // attach a callback to be triggered when the worker returns.
                worker_handle
                    .set_onmessage(Some(persistent_callback_handle.as_ref().unchecked_ref()));
            }
            Err(_) =&gt; {
                document
                    .get_element_by_id("resultField")
                    .expect("#resultField should exist")
                    .dyn_ref::&lt;HtmlElement&gt;()
                    .expect("#resultField should be a HtmlInputElement")
                    .set_inner_text("");
            }
        }
    });

    // Attach the closure as `oninput` callback to the input field.
    document
        .get_element_by_id("inputNumber")
        .expect("#inputNumber should exist")
        .dyn_ref::&lt;HtmlInputElement&gt;()
        .expect("#inputNumber should be a HtmlInputElement")
        .set_oninput(Some(callback.as_ref().unchecked_ref()));

    // Leaks memory.
    callback.forget();
}

/// Create a closure to act on the message returned by the worker
fn get_on_msg_callback() -&gt; Closure&lt;dyn FnMut(MessageEvent)&gt; {
    Closure::new(move |event: MessageEvent| {
        console::log_2(&amp;"Received response: ".into(), &amp;event.data());

        let result = match event.data().as_bool().unwrap() {
            true =&gt; "even",
            false =&gt; "odd",
        };

        let document = web_sys::window().unwrap().document().unwrap();
        document
            .get_element_by_id("resultField")
            .expect("#resultField should exist")
            .dyn_ref::&lt;HtmlElement&gt;()
            .expect("#resultField should be a HtmlInputElement")
            .set_inner_text(result);
    })
}

<span class="boring">}</span></code></pre></pre>
<h2 id="build-and-serve-13"><a class="header" href="#build-and-serve-13">build and serve</a></h2>
<blockquote>
<p>This example requires to <em>not</em> create ES modules, therefore we pass the flag
<code>--target no-modules</code></p>
</blockquote>
<pre><code class="language-sh">wasm-pack build --target no-modules --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p>NOTE:</p>
<p>You may need to Enable SharedArrayBuffers in Firefox</p>
<p>In early 2018, the Spectre and Meltdown vulnerabilities were discovered. In response, browser manufacturers disabled SharedArrayBuffer by default.</p>
<ul>
<li>Open Firefox.</li>
<li>Navigate to about:config.</li>
<li>Click I accept the risk!</li>
<li>Search for shared.</li>
<li>Double-click javascript.options.shared_memory.</li>
<li>This option should now have the value true:</li>
</ul>
<hr />
<h2 id="whats-next-16"><a class="header" href="#whats-next-16">What's next?</a></h2>
<p>Next example: <a href="./020.raytrace-parallel.html"> threads: Parallel Raytracing <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p>Previous example: <a href="./019.wasm-in-web-worker.html"> <code>&lt;--</code> web-sys: Wasm in Web Worker</a></p>
<main>
<h2 id="parallel-raytracing"><a class="header" href="#parallel-raytracing">Parallel Raytracing</a></h2>
<p><em>This is an example of using threads with WebAssembly, Rust, and wasm-bindgen, culminating in a parallel raytracer demo. There's a number of moving pieces to this demo and it's unfortunately not the easiest thing to wrangle, but it's hoped that this'll give you a bit of a taste of what it's like to use threads and wasm with Rust on the web.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/raytrace-parallel">Parallel Raytracing</a>{target="_blank"}</p>
<h3 id="building-the-demo"><a class="header" href="#building-the-demo">Building the demo</a></h3>
<p><em>One of the major gotchas with threaded WebAssembly is that Rust does not ship a precompiled target (e.g. standard library) which has threading support enabled. This means that you'll need to recompile the standard library with the appropriate rustc flags, namely -C target-feature=+atomics,+bulk-memory,+mutable-globals. Note that this requires a nightly Rust toolchain.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h3 id="setup-the-project-13"><a class="header" href="#setup-the-project-13">setup the project</a></h3>
<pre><code class="language-sh">cargo new raytrace-parallel --lib
cd raytrace-parallel
mkdir -p www/js www/html
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
console_error_panic_hook = "0.1"
js-sys = "0.3.66"
rayon = "1.1.0"
rayon-core = "1.5.0"
raytracer = { git = 'https://github.com/alexcrichton/raytracer', branch = 'update-deps' }
serde-wasm-bindgen = "0.4.3"
futures-channel-preview = "0.3.0-alpha.18"
wasm-bindgen = "0.2.89"
wasm-bindgen-futures = "0.4.39"

[dependencies.web-sys]
version = "0.3.23"
features = [
  'CanvasRenderingContext2d',
  'ErrorEvent',
  'Event',
  'ImageData',
  'Navigator',
  'Window',
  'Worker',
  'DedicatedWorkerGlobalScope',
  'MessageEvent',
]


# Replace command line  
# cargo build --target wasm32-unknown-unknown -Z build-std=panic_abort,std
# and 
# export RUSTFLAGS='-C target-feature=+atomics,+bulk-memory,+mutable-globals'
# with:
[unstable]
build-std = ['std', 'panic_abort']

[build]
target = "wasm32-unknown-unknown"
rustflags = '-Ctarget-feature=+atomics,+bulk-memory,+mutable-globals'
</code></pre>
<h3 id="the-code-5"><a class="header" href="#the-code-5">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;Parallel Raytracing: no bundle&lt;/title&gt;
    &lt;style&gt;
      #scene {
        height: 100%;
        width: 500px;
        float: left;
      }

      #render, .concurrency, .timing {
        padding: 20px;
        margin: 20px;
        float: left;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;textarea id='scene'&gt;
{
  "width": 800,
  "height": 800,
  "fov": 90.0,
  "shadow_bias": 1e-13,
  "max_recursion_depth": 20,
  "elements": [
    {
      "Sphere" : {
        "center": {
          "x": 0.0,
          "y": 0.0,
          "z": -5.0
        },
        "radius": 1.0,
        "material": {
          "coloration" : {
            "Color": {
              "red": 0.2,
              "green": 1.0,
              "blue": 0.2
            }
          },
          "albedo": 0.18,
          "surface": {
            "Reflective": {
              "reflectivity": 0.7
            }
          }
        }
      }
    },
    {
      "Sphere" : {
        "center": {
          "x": -3.0,
          "y": 1.0,
          "z": -6.0
        },
        "radius": 2.0,
        "material": {
          "coloration": {
            "Color": {
              "red": 1.0,
              "green": 1.0,
              "blue": 1.0
            }
          },
          "albedo": 0.58,
          "surface": "Diffuse"
        }
      }
    },
    {
      "Sphere": {
        "center": {
          "x": 2.0,
          "y": 1.0,
          "z": -4.0
        },
        "radius": 1.5,
        "material": {
          "coloration": {
            "Color": {
              "red": 1.0,
              "green": 1.0,
              "blue": 1.0
            }
          },
          "albedo": 0.18,
          "surface": {
            "Refractive": {
              "index": 1.5,
              "transparency": 1.0
            }
          }
        }
      }
    },
    {
      "Plane": {
        "origin": {
          "x": 0.0,
          "y": -2.0,
          "z": -5.0
        },
        "normal": {
          "x": 0.0,
          "y": -1.0,
          "z": 0.0
        },
        "material": {
          "coloration": {
            "Color": {
              "red": 1.0,
              "green": 1.0,
              "blue": 1.0
            }
          },
          "albedo": 0.18,
          "surface": {
            "Reflective": {
              "reflectivity": 0.5
            }
          }
        }
      }
    },
    {
      "Plane": {
        "origin": {
          "x": 0.0,
          "y": 0.0,
          "z": -20.0
        },
        "normal": {
          "x": 0.0,
          "y": 0.0,
          "z": -1.0
        },
        "material": {
          "coloration": {
            "Color": {
              "red": 0.2,
              "green": 0.3,
              "blue": 1.0
            }
          },
          "albedo": 0.38,
          "surface": "Diffuse"
        }
      }
    }
  ],
  "lights": [
    {
      "Spherical": {
        "position": {
          "x": -2.0,
          "y": 10.0,
          "z": -3.0
        },
        "color": {
          "red": 0.3,
          "green": 0.8,
          "blue": 0.3
        },
        "intensity": 10000.0
      }
    },
    {
      "Spherical": {
        "position": {
          "x": 0.25,
          "y": 0.0,
          "z": -2.0
        },
        "color": {
          "red": 0.8,
          "green": 0.3,
          "blue": 0.3
        },
        "intensity": 250.0
      }
    },
    {
      "Directional": {
        "direction": {
          "x": 0.0,
          "y": 0.0,
          "z": -1.0
        },
        "color": {
          "red": 1.0,
          "green": 1.0,
          "blue": 1.0
        },
        "intensity": 0.0
      }
    }
  ]
}
    &lt;/textarea&gt;

    &lt;button disabled id='render'&gt;Loading wasm...&lt;/button&gt;
    &lt;div class='concurrency'&gt;
      &lt;p id='concurrency-amt'&gt;Concurrency: 1&lt;/p&gt;
      &lt;br/&gt;
      &lt;input disabled type="range" id="concurrency" min="0" max="1" /&gt;
    &lt;/div&gt;
    &lt;div id='timing'&gt;
      Render duration:
      &lt;p id='timing-val'&gt;&lt;/p&gt;
    &lt;/div&gt;


    &lt;canvas id='canvas'&gt;&lt;/canvas&gt;

    &lt;script&gt;
      document.getElementById('render').disabled = true;
      document.getElementById('concurrency').disabled = true;
    &lt;/script&gt;
    &lt;script src='../pkg/raytrace_parallel.js'&gt;&lt;/script&gt;
    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">const button = document.getElementById('render');
const canvas = document.getElementById('canvas');
const scene = document.getElementById('scene');
const concurrency = document.getElementById('concurrency');
const concurrencyAmt = document.getElementById('concurrency-amt');
const timing = document.getElementById('timing');
const timingVal = document.getElementById('timing-val');
const ctx = canvas.getContext('2d');

button.disabled = true;
concurrency.disabled = true;

// First up, but try to do feature detection to provide better error messages
function loadWasm() {
  let msg = 'This demo requires a current version of Firefox (e.g., 79.0)';
  if (typeof SharedArrayBuffer !== 'function') {
    alert('this browser does not have SharedArrayBuffer support enabled' + '\n\n' + msg);
    return
  }
  // Test for bulk memory operations with passive data segments
  //  (module (memory 1) (data passive ""))
  const buf = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
    0x05, 0x03, 0x01, 0x00, 0x01, 0x0b, 0x03, 0x01, 0x01, 0x00]);
  if (!WebAssembly.validate(buf)) {
    alert('this browser does not support passive wasm memory, demo does not work' + '\n\n' + msg);
    return
  }

  wasm_bindgen()
    .then(run)
    .catch(console.error);
}

loadWasm();

const { Scene, WorkerPool } = wasm_bindgen;

function run() {
  // The maximal concurrency of our web worker pool is `hardwareConcurrency`,
  // so set that up here and this ideally is the only location we create web
  // workers.
  pool = new WorkerPool(navigator.hardwareConcurrency);

  // Configure various buttons and such.
  button.onclick = function() {
    button.disabled = true;
    console.time('render');
    let json;
    try {
      json = JSON.parse(scene.value);
    } catch(e) {
      alert(`invalid json: ${e}`);
      return
    }
    canvas.width = json.width;
    canvas.height = json.height;
    render(new Scene(json));
  };
  button.innerText = 'Render!';
  button.disabled = false;

  concurrency.oninput = function() {
    concurrencyAmt.innerText = 'Concurrency: ' + concurrency.value;
  };
  concurrency.min = 1;
  concurrency.step = 1;
  concurrency.max = navigator.hardwareConcurrency;
  concurrency.value = concurrency.max;
  concurrency.oninput();
  concurrency.disabled = false;
}

let rendering = null;
let start = null;
let interval = null;
let pool = null;

class State {
  constructor(wasm) {
    this.start = performance.now();
    this.wasm = wasm;
    this.running = true;
    this.counter = 1;

    this.interval = setInterval(() =&gt; this.updateTimer(true), 100);

    wasm.promise()
      .then(data =&gt; {
        this.updateTimer(false);
        this.updateImage(data);
        this.stop();
      })
      .catch(console.error);
  }

  updateTimer(updateImage) {
    const dur = performance.now() - this.start;
    timingVal.innerText = `${dur}ms`;
    this.counter += 1;

    if (updateImage &amp;&amp; this.wasm &amp;&amp; this.counter % 3 == 0)
      this.updateImage(this.wasm.imageSoFar());
  }

  updateImage(data) {
    ctx.putImageData(data, 0, 0);
  }

  stop() {
    if (!this.running)
      return;
    console.timeEnd('render');
    this.running = false;
    this.wasm = null;
    clearInterval(this.interval);
    button.disabled = false;
  }
}

function render(scene) {
  if (rendering) {
    rendering.stop();
    rendering = null;
  }
  rendering = new State(scene.render(parseInt(concurrency.value), pool));
}

</code></pre>
<ul>
<li>worker.js</li>
</ul>
<pre><code class="language-js">// synchronously, using the browser, import out shim JS scripts
importScripts('pkg/raytrace_parallel.js');

// Wait for the main thread to send us the shared module/memory. Once we've got
// it, initialize it all with the `wasm_bindgen` global we imported via
// `importScripts`.
//
// After our first message all subsequent messages are an entry point to run,
// so we just do that.
self.onmessage = event =&gt; {
  let initialised = wasm_bindgen(...event.data).catch(err =&gt; {
    // Propagate to main `onerror`:
    setTimeout(() =&gt; {
      throw err;
    });
    // Rethrow to keep promise rejected and prevent execution of further commands:
    throw err;
  });

  self.onmessage = async event =&gt; {
    // This will queue further commands up until the module is fully initialised:
    await initialised;
    wasm_bindgen.child_entry_point(event.data);
  };
};

</code></pre>
<ul>
<li>Rust side</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
use futures_channel::oneshot;
use js_sys::{Promise, Uint8ClampedArray, WebAssembly};
use rayon::prelude::*;
use wasm_bindgen::prelude::*;

macro_rules! console_log {
    ($($t:tt)*) =&gt; (crate::log(&amp;format_args!($($t)*).to_string()))
}

mod pool;

#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &amp;str);
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn logv(x: &amp;JsValue);
}

#[wasm_bindgen]
pub struct Scene {
    inner: raytracer::scene::Scene,
}

#[wasm_bindgen]
impl Scene {
    /// Creates a new scene from the JSON description in `object`, which we
    /// deserialize here into an actual scene.
    #[wasm_bindgen(constructor)]
    pub fn new(object: JsValue) -&gt; Result&lt;Scene, JsValue&gt; {
        console_error_panic_hook::set_once();
        Ok(Scene {
            inner: serde_wasm_bindgen::from_value(object)
                .map_err(|e| JsValue::from(e.to_string()))?,
        })
    }

    /// Renders this scene with the provided concurrency and worker pool.
    ///
    /// This will spawn up to `concurrency` workers which are loaded from or
    /// spawned into `pool`. The `RenderingScene` state contains information to
    /// get notifications when the render has completed.
    pub fn render(
        self,
        concurrency: usize,
        pool: &amp;pool::WorkerPool,
    ) -&gt; Result&lt;RenderingScene, JsValue&gt; {
        let scene = self.inner;
        let height = scene.height;
        let width = scene.width;

        // Allocate the pixel data which our threads will be writing into.
        let pixels = (width * height) as usize;
        let mut rgb_data = vec![0; 4 * pixels];
        let base = rgb_data.as_ptr() as usize;
        let len = rgb_data.len();

        // Configure a rayon thread pool which will pull web workers from
        // `pool`.
        let thread_pool = rayon::ThreadPoolBuilder::new()
            .num_threads(concurrency)
            .spawn_handler(|thread| {
                pool.run(|| thread.run()).unwrap();
                Ok(())
            })
            .build()
            .unwrap();

        // And now execute the render! The entire render happens on our worker
        // threads so we don't lock up the main thread, so we ship off a thread
        // which actually does the whole rayon business. When our returned
        // future is resolved we can pull out the final version of the image.
        let (tx, rx) = oneshot::channel();
        pool.run(move || {
            thread_pool.install(|| {
                rgb_data
                    .par_chunks_mut(4)
                    .enumerate()
                    .for_each(|(i, chunk)| {
                        let i = i as u32;
                        let x = i % width;
                        let y = i / width;
                        let ray = raytracer::Ray::create_prime(x, y, &amp;scene);
                        let result = raytracer::cast_ray(&amp;scene, &amp;ray, 0).to_rgba();
                        chunk[0] = result.data[0];
                        chunk[1] = result.data[1];
                        chunk[2] = result.data[2];
                        chunk[3] = result.data[3];
                    });
            });
            drop(tx.send(rgb_data));
        })?;

        let done = async move {
            match rx.await {
                Ok(_data) =&gt; Ok(image_data(base, len, width, height).into()),
                Err(_) =&gt; Err(JsValue::undefined()),
            }
        };

        Ok(RenderingScene {
            promise: wasm_bindgen_futures::future_to_promise(done),
            base,
            len,
            height,
            width,
        })
    }
}

#[wasm_bindgen]
pub struct RenderingScene {
    base: usize,
    len: usize,
    promise: Promise,
    width: u32,
    height: u32,
}

// Inline the definition of `ImageData` here because `web_sys` uses
// `&amp;Clamped&lt;Vec&lt;u8&gt;&gt;`, whereas we want to pass in a JS object here.
#[wasm_bindgen]
extern "C" {
    pub type ImageData;

    #[wasm_bindgen(constructor, catch)]
    fn new(data: &amp;Uint8ClampedArray, width: f64, height: f64) -&gt; Result&lt;ImageData, JsValue&gt;;
}

#[wasm_bindgen]
impl RenderingScene {
    /// Returns the JS promise object which resolves when the render is complete
    pub fn promise(&amp;self) -&gt; Promise {
        self.promise.clone()
    }

    /// Return a progressive rendering of the image so far
    #[wasm_bindgen(js_name = imageSoFar)]
    pub fn image_so_far(&amp;self) -&gt; ImageData {
        image_data(self.base, self.len, self.width, self.height)
    }
}

fn image_data(base: usize, len: usize, width: u32, height: u32) -&gt; ImageData {
    // Use the raw access available through `memory.buffer`, but be sure to
    // use `slice` instead of `subarray` to create a copy that isn't backed
    // by `SharedArrayBuffer`. Currently `ImageData` rejects a view of
    // `Uint8ClampedArray` that's backed by a shared buffer.
    //
    // FIXME: that this may or may not be UB based on Rust's rules. For example
    // threads may be doing unsynchronized writes to pixel data as we read it
    // off here. In the context of wasm this may or may not be UB, we're
    // unclear! In any case for now it seems to work and produces a nifty
    // progressive rendering. A more production-ready application may prefer to
    // instead use some form of signaling here to request an update from the
    // workers instead of synchronously acquiring an update, and that way we
    // could ensure that even on the Rust side of things it's not UB.
    let mem = wasm_bindgen::memory().unchecked_into::&lt;WebAssembly::Memory&gt;();
    let mem = Uint8ClampedArray::new(&amp;mem.buffer()).slice(base as u32, (base + len) as u32);
    ImageData::new(&amp;mem, width as f64, height as f64).unwrap()
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>pool.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/pool.rs
// Silences warnings from the compiler about Work.func and child_entry_point
// being unused when the target is not wasm.
#![cfg_attr(not(target_arch = "wasm32"), allow(dead_code))]

//! A small module that's intended to provide an example of creating a pool of
//! web workers which can be used to execute `rayon`-style work.

use std::cell::RefCell;
use std::rc::Rc;
use wasm_bindgen::prelude::*;
use web_sys::{DedicatedWorkerGlobalScope, MessageEvent};
use web_sys::{ErrorEvent, Event, Worker};

#[wasm_bindgen]
pub struct WorkerPool {
    state: Rc&lt;PoolState&gt;,
}

struct PoolState {
    workers: RefCell&lt;Vec&lt;Worker&gt;&gt;,
    callback: Closure&lt;dyn FnMut(Event)&gt;,
}

struct Work {
    func: Box&lt;dyn FnOnce() + Send&gt;,
}

#[wasm_bindgen]
impl WorkerPool {
    /// Creates a new `WorkerPool` which immediately creates `initial` workers.
    ///
    /// The pool created here can be used over a long period of time, and it
    /// will be initially primed with `initial` workers. Currently workers are
    /// never released or gc'd until the whole pool is destroyed.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    #[wasm_bindgen(constructor)]
    pub fn new(initial: usize) -&gt; Result&lt;WorkerPool, JsValue&gt; {
        let pool = WorkerPool {
            state: Rc::new(PoolState {
                workers: RefCell::new(Vec::with_capacity(initial)),
                callback: Closure::new(|event: Event| {
                    console_log!("unhandled event: {}", event.type_());
                    crate::logv(&amp;event);
                }),
            }),
        };
        for _ in 0..initial {
            let worker = pool.spawn()?;
            pool.state.push(worker);
        }

        Ok(pool)
    }

    /// Unconditionally spawns a new worker
    ///
    /// The worker isn't registered with this `WorkerPool` but is capable of
    /// executing work for this wasm module.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn spawn(&amp;self) -&gt; Result&lt;Worker, JsValue&gt; {
        console_log!("spawning new worker");
        // TODO: what do do about `./worker.js`:
        //
        // * the path is only known by the bundler. How can we, as a
        //   library, know what's going on?
        // * How do we not fetch a script N times? It internally then
        //   causes another script to get fetched N times...
        let worker = Worker::new("./worker.js")?;

        // With a worker spun up send it the module/memory so it can start
        // instantiating the wasm module. Later it might receive further
        // messages about code to run on the wasm module.
        let array = js_sys::Array::new();
        array.push(&amp;wasm_bindgen::module());
        array.push(&amp;wasm_bindgen::memory());
        worker.post_message(&amp;array)?;

        Ok(worker)
    }

    /// Fetches a worker from this pool, spawning one if necessary.
    ///
    /// This will attempt to pull an already-spawned web worker from our cache
    /// if one is available, otherwise it will spawn a new worker and return the
    /// newly spawned worker.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn worker(&amp;self) -&gt; Result&lt;Worker, JsValue&gt; {
        match self.state.workers.borrow_mut().pop() {
            Some(worker) =&gt; Ok(worker),
            None =&gt; self.spawn(),
        }
    }

    /// Executes the work `f` in a web worker, spawning a web worker if
    /// necessary.
    ///
    /// This will acquire a web worker and then send the closure `f` to the
    /// worker to execute. The worker won't be usable for anything else while
    /// `f` is executing, and no callbacks are registered for when the worker
    /// finishes.
    ///
    /// # Errors
    ///
    /// Returns any error that may happen while a JS web worker is created and a
    /// message is sent to it.
    fn execute(&amp;self, f: impl FnOnce() + Send + 'static) -&gt; Result&lt;Worker, JsValue&gt; {
        let worker = self.worker()?;
        let work = Box::new(Work { func: Box::new(f) });
        let ptr = Box::into_raw(work);
        match worker.post_message(&amp;JsValue::from(ptr as u32)) {
            Ok(()) =&gt; Ok(worker),
            Err(e) =&gt; {
                unsafe {
                    drop(Box::from_raw(ptr));
                }
                Err(e)
            }
        }
    }

    /// Configures an `onmessage` callback for the `worker` specified for the
    /// web worker to be reclaimed and re-inserted into this pool when a message
    /// is received.
    ///
    /// Currently this `WorkerPool` abstraction is intended to execute one-off
    /// style work where the work itself doesn't send any notifications and
    /// whatn it's done the worker is ready to execute more work. This method is
    /// used for all spawned workers to ensure that when the work is finished
    /// the worker is reclaimed back into this pool.
    fn reclaim_on_message(&amp;self, worker: Worker) {
        let state = Rc::downgrade(&amp;self.state);
        let worker2 = worker.clone();
        let reclaim_slot = Rc::new(RefCell::new(None));
        let slot2 = reclaim_slot.clone();
        let reclaim = Closure::&lt;dyn FnMut(_)&gt;::new(move |event: Event| {
            if let Some(error) = event.dyn_ref::&lt;ErrorEvent&gt;() {
                console_log!("error in worker: {}", error.message());
                // TODO: this probably leaks memory somehow? It's sort of
                // unclear what to do about errors in workers right now.
                return;
            }

            // If this is a completion event then can deallocate our own
            // callback by clearing out `slot2` which contains our own closure.
            if let Some(_msg) = event.dyn_ref::&lt;MessageEvent&gt;() {
                if let Some(state) = state.upgrade() {
                    state.push(worker2.clone());
                }
                *slot2.borrow_mut() = None;
                return;
            }

            console_log!("unhandled event: {}", event.type_());
            crate::logv(&amp;event);
            // TODO: like above, maybe a memory leak here?
        });
        worker.set_onmessage(Some(reclaim.as_ref().unchecked_ref()));
        *reclaim_slot.borrow_mut() = Some(reclaim);
    }
}

impl WorkerPool {
    /// Executes `f` in a web worker.
    ///
    /// This pool manages a set of web workers to draw from, and `f` will be
    /// spawned quickly into one if the worker is idle. If no idle workers are
    /// available then a new web worker will be spawned.
    ///
    /// Once `f` returns the worker assigned to `f` is automatically reclaimed
    /// by this `WorkerPool`. This method provides no method of learning when
    /// `f` completes, and for that you'll need to use `run_notify`.
    ///
    /// # Errors
    ///
    /// If an error happens while spawning a web worker or sending a message to
    /// a web worker, that error is returned.
    pub fn run(&amp;self, f: impl FnOnce() + Send + 'static) -&gt; Result&lt;(), JsValue&gt; {
        let worker = self.execute(f)?;
        self.reclaim_on_message(worker);
        Ok(())
    }
}

impl PoolState {
    fn push(&amp;self, worker: Worker) {
        worker.set_onmessage(Some(self.callback.as_ref().unchecked_ref()));
        worker.set_onerror(Some(self.callback.as_ref().unchecked_ref()));
        let mut workers = self.workers.borrow_mut();
        for prev in workers.iter() {
            let prev: &amp;JsValue = prev;
            let worker: &amp;JsValue = &amp;worker;
            assert!(prev != worker);
        }
        workers.push(worker);
    }
}

/// Entry point invoked by `worker.js`, a bit of a hack but see the "TODO" above
/// about `worker.js` in general.
#[wasm_bindgen]
pub fn child_entry_point(ptr: u32) -&gt; Result&lt;(), JsValue&gt; {
    let ptr = unsafe { Box::from_raw(ptr as *mut Work) };
    let global = js_sys::global().unchecked_into::&lt;DedicatedWorkerGlobalScope&gt;();
    (ptr.func)();
    global.post_message(&amp;JsValue::undefined())?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-the-demo"><a class="header" href="#running-the-demo">Running the demo</a></h3>
<p>"<em>Currently it's required to use the --target no-modules or --target web flag with wasm-bindgen to run threaded code. This is because the WebAssembly file imports memory instead of exporting it, so we need to hook initialization of the wasm module at this time to provide the appropriate memory object. This demo uses --target no-modules, because Firefox does not support modules in workers.</em></p>
<p><em>With --target no-modules you'll be able to use importScripts inside of each web worker to import the shim JS generated by wasm-bindgen as well as calling the wasm_bindgen initialization function with the shared memory instance from the main thread. The expected usage is that WebAssembly on the main thread will post its memory object to all other threads to get instantiated with.</em>"<br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h2 id="build-and-serve-14"><a class="header" href="#build-and-serve-14">build and serve</a></h2>
<blockquote>
<p>This example requires to <em>not</em> create ES modules, therefore we pass the flag
<code>--target no-modules</code></p>
</blockquote>
<pre><code class="language-sh">wasm-pack build --target no-modules --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-17"><a class="header" href="#whats-next-17">What's next?</a></h2>
<p>Next example: <a href="./021.wasm-audio-worklet.html"> Wasm audio worklet <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p>Previous example: <a href="./019.wasm-in-web-worker.html"> <code>&lt;--</code> web-sys: Wasm in Web Worker</a></p>
<main>
<h2 id="wasm-audio-worklet"><a class="header" href="#wasm-audio-worklet">Wasm audio worklet</a></h2>
<p><em>This is an example of using threads inside specific worklets with WebAssembly, Rust, and wasm-bindgen, culminating in an oscillator demo. This demo should complement the parallel-raytrace example by demonstrating an alternative approach using ES modules with on-the-fly module creation.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-audio-worklet.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/wasm-audio-worklet">Parallel Raytracing</a>{target="_blank"}</p>
<h3 id="building-the-demo-1"><a class="header" href="#building-the-demo-1">Building the demo</a></h3>
<p><em>One of the major gotchas with threaded WebAssembly is that Rust does not ship a precompiled target (e.g. standard library) which has threading support enabled. This means that you'll need to recompile the standard library with the appropriate rustc flags, namely -C target-feature=+atomics,+bulk-memory,+mutable-globals. Note that this requires a nightly Rust toolchain.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">see  more detailed instructions of the parallel-raytrace example</a>{target="_blank"}</p>
<h4 id="rust-toolchaintoml"><a class="header" href="#rust-toolchaintoml">rust-toolchain.toml</a></h4>
<pre><code class="language-toml">[toolchain]
channel = "nightly"
components = ["rust-src"]
targets = ["wasm32-unknown-unknown"]
profile = "minimal"
</code></pre>
<h4 id="caveats"><a class="header" href="#caveats">Caveats</a></h4>
<p><em>This example shares most of its caveats with the parallel-raytrace example. However, it tries to encapsulate worklet creation in a Rust module, so the application developer does not need to maintain custom JS code.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-audio-worklet.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h4 id="browser-requirements"><a class="header" href="#browser-requirements">Browser Requirements</a></h4>
<p><em>This demo should work in the latest Chrome and Safari versions at this time. Firefox does not support imports in worklet modules, which are difficult to avoid in this example, as importScripts is unavailable in worklets. Note that this example requires HTTP headers to be set like in parallel-raytrace.</em>
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/wasm-audio-worklet.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h3 id="setup-the-project-14"><a class="header" href="#setup-the-project-14">setup the project</a></h3>
<pre><code class="language-sh">cargo new wasm-audio-worklet --lib
cd wasm-audio-worklet
mkdir -p www/js www/html
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[dependencies]
console_log = "0.2.0"
js-sys = "0.3.66"
wasm-bindgen = "0.2.89"
wasm-bindgen-futures = "0.4.39"

[dependencies.web-sys]
version = "0.3.66"
features = [
  "AudioContext",
  "AudioDestinationNode",
  "AudioWorklet",
  "AudioWorkletNode",
  "AudioWorkletNodeOptions",
  "Blob",
  "BlobPropertyBag",
  "Document",
  "Event",
  "HtmlInputElement",
  "HtmlLabelElement",
  "Url",
  "Window",
]


# Replace command line  
# cargo build --target wasm32-unknown-unknown -Z build-std=panic_abort,std
# and 
# export RUSTFLAGS='-C target-feature=+atomics,+bulk-memory,+mutable-globals'
# with:
[unstable]
build-std = ['std', 'panic_abort']

[build]
target = "wasm32-unknown-unknown"
rustflags = '-Ctarget-feature=+atomics,+bulk-memory,+mutable-globals'
</code></pre>
<h3 id="the-code-6"><a class="header" href="#the-code-6">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Wasm audio worklet&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type="module"&gt;
            import init, {web_main} from "../pkg/wasm_audio_worklet.js";
            async function run() {
                await init();
                web_main();
            }
            run();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<ul>
<li>index.js</li>
</ul>
<p>No index.js for this example we have it directly in the html file.</p>
<ul>
<li>worklet.js</li>
</ul>
<pre><code class="language-js">registerProcessor("WasmProcessor", class WasmProcessor extends AudioWorkletProcessor {
    constructor(options) {
        super();
        let [module, memory, handle] = options.processorOptions;
        bindgen.initSync(module, memory);
        this.processor = bindgen.WasmAudioProcessor.unpack(handle);
    }
    process(inputs, outputs) {
        return this.processor.process(outputs[0][0]);
    }
});
</code></pre>
<ul>
<li>Rust side</li>
</ul>
<ul>
<li>lib.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
mod dependent_module;
mod gui;
mod oscillator;
mod wasm_audio;

use gui::create_gui;
use oscillator::{Oscillator, Params};
use wasm_audio::wasm_audio;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub async fn web_main() {
    // On the application level, audio worklet internals are abstracted by wasm_audio:
    let params: &amp;'static Params = Box::leak(Box::default());
    let mut osc = Oscillator::new(params);
    let ctx = wasm_audio(Box::new(move |buf| osc.process(buf)))
        .await
        .unwrap();
    create_gui(params, ctx);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>dependent_module</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use js_sys::{Array, JsString};
use wasm_bindgen::prelude::*;
use web_sys::{Blob, BlobPropertyBag, Url};

// This is a not-so-clean approach to get the current bindgen ES module URL
// in Rust. This will fail at run time on bindgen targets not using ES modules.
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen]
    type ImportMeta;

    #[wasm_bindgen(method, getter)]
    fn url(this: &amp;ImportMeta) -&gt; JsString;

    #[wasm_bindgen(js_namespace = import, js_name = meta)]
    static IMPORT_META: ImportMeta;
}

pub fn on_the_fly(code: &amp;str) -&gt; Result&lt;String, JsValue&gt; {
    // Generate the import of the bindgen ES module, assuming `--target web`.
    let header = format!(
        "import init, * as bindgen from '{}';\n\n",
        IMPORT_META.url(),
    );

    Url::create_object_url_with_blob(&amp;Blob::new_with_str_sequence_and_options(
        &amp;Array::of2(&amp;JsValue::from(header.as_str()), &amp;JsValue::from(code)),
        BlobPropertyBag::new().type_("text/javascript"),
    )?)
}

// dependent_module! takes a local file name to a JS module as input and
// returns a URL to a slightly modified module in run time. This modified module
// has an additional import statement in the header that imports the current
// bindgen JS module under the `bindgen` alias, and the separate init function.
// How this URL is produced does not matter for the macro user. on_the_fly
// creates a blob URL in run time. A better, more sophisticated solution
// would add wasm_bindgen support to put such a module in pkg/ during build time
// and return a URL to this file instead (described in #3019).
#[macro_export]
macro_rules! dependent_module {
    ($file_name:expr) =&gt; {
        $crate::dependent_module::on_the_fly(include_str!($file_name))
    };
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>gui</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::oscillator::Params;
use wasm_bindgen::{closure::Closure, JsCast, JsValue};
use web_sys::{AudioContext, HtmlInputElement, HtmlLabelElement};

pub fn create_gui(params: &amp;'static Params, ctx: AudioContext) {
    let window = web_sys::window().unwrap();
    let document = window.document().unwrap();
    let body = document.body().unwrap();

    let volume = add_slider(&amp;document, &amp;body, "Volume:").unwrap();
    let frequency = add_slider(&amp;document, &amp;body, "Frequency:").unwrap();
    volume.set_value("0");
    frequency.set_min("20");
    frequency.set_value("60");

    let listener = Closure::&lt;dyn FnMut(_)&gt;::new(move |_: web_sys::Event| {
        params.set_frequency(frequency.value().parse().unwrap());
        params.set_volume(volume.value().parse().unwrap());
        drop(ctx.resume().unwrap());
    })
    .into_js_value();

    body.add_event_listener_with_callback("input", listener.as_ref().unchecked_ref())
        .unwrap();
}

fn add_slider(
    document: &amp;web_sys::Document,
    body: &amp;web_sys::HtmlElement,
    name: &amp;str,
) -&gt; Result&lt;HtmlInputElement, JsValue&gt; {
    let input: HtmlInputElement = document.create_element("input")?.unchecked_into();
    let label: HtmlLabelElement = document.create_element("label")?.unchecked_into();
    input.set_type("range");
    label.set_text_content(Some(name));
    label.append_child(&amp;input)?;
    body.append_child(&amp;label)?;
    Ok(input)
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>oscillator</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Wasm audio processors can be implemented in Rust without knowing
// about audio worklets.

use std::sync::atomic::{AtomicU8, Ordering};

// Let's implement a simple sine oscillator with variable frequency and volume.
pub struct Oscillator {
    params: &amp;'static Params,
    accumulator: u32,
}

impl Oscillator {
    pub fn new(params: &amp;'static Params) -&gt; Self {
        Self {
            params,
            accumulator: 0,
        }
    }
}

impl Oscillator {
    pub fn process(&amp;mut self, output: &amp;mut [f32]) -&gt; bool {
        // This method is called in the audio process thread.
        // All imports are set, so host functionality available in worklets
        // (for example, logging) can be used:
        // `web_sys::console::log_1(&amp;JsValue::from(output.len()));`
        // Note that currently TextEncoder and TextDecoder are stubs, so passing
        // strings may not work in this thread.
        for a in output {
            let frequency = self.params.frequency.load(Ordering::Relaxed);
            let volume = self.params.volume.load(Ordering::Relaxed);
            self.accumulator += u32::from(frequency);
            *a = (self.accumulator as f32 / 512.).sin() * (volume as f32 / 100.);
        }
        true
    }
}

#[derive(Default)]
pub struct Params {
    // Use atomics for parameters so they can be set in the main thread and
    // fetched by the audio process thread without further synchronization.
    frequency: AtomicU8,
    volume: AtomicU8,
}

impl Params {
    pub fn set_frequency(&amp;self, frequency: u8) {
        self.frequency.store(frequency, Ordering::Relaxed);
    }
    pub fn set_volume(&amp;self, volume: u8) {
        self.volume.store(volume, Ordering::Relaxed);
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>wasm_audio</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::dependent_module;
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsValue;
use wasm_bindgen_futures::JsFuture;
use web_sys::{AudioContext, AudioWorkletNode, AudioWorkletNodeOptions};

#[wasm_bindgen]
pub struct WasmAudioProcessor(Box&lt;dyn FnMut(&amp;mut [f32]) -&gt; bool&gt;);

#[wasm_bindgen]
impl WasmAudioProcessor {
    pub fn process(&amp;mut self, buf: &amp;mut [f32]) -&gt; bool {
        self.0(buf)
    }
    pub fn pack(self) -&gt; usize {
        Box::into_raw(Box::new(self)) as usize
    }
    pub unsafe fn unpack(val: usize) -&gt; Self {
        *Box::from_raw(val as *mut _)
    }
}

// Use wasm_audio if you have a single wasm audio processor in your application
// whose samples should be played directly. Ideally, call wasm_audio based on
// user interaction. Otherwise, resume the context on user interaction, so
// playback starts reliably on all browsers.
pub async fn wasm_audio(
    process: Box&lt;dyn FnMut(&amp;mut [f32]) -&gt; bool&gt;,
) -&gt; Result&lt;AudioContext, JsValue&gt; {
    let ctx = AudioContext::new()?;
    prepare_wasm_audio(&amp;ctx).await?;
    let node = wasm_audio_node(&amp;ctx, process)?;
    node.connect_with_audio_node(&amp;ctx.destination())?;
    Ok(ctx)
}

// wasm_audio_node creates an AudioWorkletNode running a wasm audio processor.
// Remember to call prepare_wasm_audio once on your context before calling
// this function.
pub fn wasm_audio_node(
    ctx: &amp;AudioContext,
    process: Box&lt;dyn FnMut(&amp;mut [f32]) -&gt; bool&gt;,
) -&gt; Result&lt;AudioWorkletNode, JsValue&gt; {
    AudioWorkletNode::new_with_options(
        ctx,
        "WasmProcessor",
        AudioWorkletNodeOptions::new().processor_options(Some(&amp;js_sys::Array::of3(
            &amp;wasm_bindgen::module(),
            &amp;wasm_bindgen::memory(),
            &amp;WasmAudioProcessor(process).pack().into(),
        ))),
    )
}

pub async fn prepare_wasm_audio(ctx: &amp;AudioContext) -&gt; Result&lt;(), JsValue&gt; {
    let mod_url = dependent_module!("worklet.js")?;
    JsFuture::from(ctx.audio_worklet()?.add_module(&amp;mod_url)?).await?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="running-the-demo-1"><a class="header" href="#running-the-demo-1">Running the demo</a></h3>
<p>"<em>Currently it's required to use the --target no-modules or --target web flag with wasm-bindgen to run threaded code. This is because the WebAssembly file imports memory instead of exporting it, so we need to hook initialization of the wasm module at this time to provide the appropriate memory object. This demo uses --target no-modules, because Firefox does not support modules in workers.</em></p>
<p><em>With --target no-modules you'll be able to use importScripts inside of each web worker to import the shim JS generated by wasm-bindgen as well as calling the wasm_bindgen initialization function with the shared memory instance from the main thread. The expected usage is that WebAssembly on the main thread will post its memory object to all other threads to get instantiated with.</em>"<br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h2 id="build-and-serve-15"><a class="header" href="#build-and-serve-15">build and serve</a></h2>
<blockquote>
<p>This example requires to <em>not</em> create ES modules, therefore we pass the flag
<code>--target no-modules</code></p>
</blockquote>
<pre><code class="language-sh">wasm-pack build --target no-modules --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<hr />
<h2 id="whats-next-18"><a class="header" href="#whats-next-18">What's next?</a></h2>
<p>Next example: <a href="./022.todomvc.html"> TODO MVC using wasm-bingen and web-sys <code>--&gt;</code></a></p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div class="navbar"><a class="openbtn" onclick="openNav()">&#9776;</a></div>
<p>Previous example: <a href="./019.wasm-in-web-worker.html"> <code>&lt;--</code> web-sys: Wasm in Web Worker</a></p>
<main>
<h2 id="todo-mvc"><a class="header" href="#todo-mvc">TODO MVC</a></h2>
<p><em>wasm-bindgen and web-sys coded TODO MVC</p>
<p>The code was rewritten from the ES6 version.</p>
<p>The core differences are:</p>
<pre><code>Having an Element wrapper that takes care of dyn and into refs in web-sys,  
A Scheduler that allows Controller and View to communicate to each other by emulating something similar to the JS event loop.
</code></pre>
</em>  
   _ [wasm-bindgen Guide](https://rustwasm.github.io/wasm-bindgen/examples/todomvc.html){target="_blank"}
<p><a href="https://github.com/rustwasm/wasm-bindgen/tree/master/examples/todomvc">Parallel Raytracing</a>{target="_blank"}</p>
<h3 id="building-the-demo-2"><a class="header" href="#building-the-demo-2">Building the demo</a></h3>
<p><em>One of the major gotchas with threaded WebAssembly is that Rust does not ship a precompiled target (e.g. standard library) which has threading support enabled. This means that you'll need to recompile the standard library with the appropriate rustc flags, namely -C target-feature=+atomics,+bulk-memory,+mutable-globals. Note that this requires a nightly Rust toolchain.</em><br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h3 id="setup-the-project-15"><a class="header" href="#setup-the-project-15">setup the project</a></h3>
<pre><code class="language-sh">cargo new todomvc --lib
cd todomvc
mkdir -p www/js www/html www/html/templates
</code></pre>
<ul>
<li>Edit Cargo.toml</li>
</ul>
<pre><code class="language-toml">[lib]
crate-type = ["cdylib"]

[build-dependencies]
askama = "0.10.0"

[dependencies]
js-sys = "0.3.66"
wasm-bindgen = "0.2.89"
askama = "0.10.0"
console_error_panic_hook = "0.1.5"

[dependencies.web-sys]
version = "0.3.5"
features = [
  'console',
  'CssStyleDeclaration',
  'Document',
  'DomStringMap',
  'DomTokenList',
  'Element',
  'Event',
  'EventTarget',
  'HtmlBodyElement',
  'HtmlElement',
  'HtmlInputElement',
  'KeyboardEvent',
  'Location',
  'Node',
  'NodeList',
  'Storage',
  'Window',
]
</code></pre>
<h3 id="the-code-7"><a class="header" href="#the-code-7">The code</a></h3>
<ul>
<li>index.html</li>
</ul>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta content="text/html;charset=utf-8" http-equiv="Content-Type"/&gt;
    &lt;title&gt;web-sys Wasm • TodoMVC&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;section class="todoapp"&gt;
      &lt;header class="header"&gt;
        &lt;h1&gt;todos&lt;/h1&gt;
        &lt;input class="new-todo" placeholder="What needs to be done?" autofocus&gt;
      &lt;/header&gt;
      &lt;section hidden class="main"&gt;
        &lt;input id="toggle-all" class="toggle-all" type="checkbox"&gt;
        &lt;label for="toggle-all"&gt;Mark all as complete&lt;/label&gt;
        &lt;ul class="todo-list"&gt;&lt;/ul&gt;
        &lt;footer class="footer"&gt;
          &lt;span class="todo-count"&gt;&lt;/span&gt;
          &lt;ul class="filters"&gt;
            &lt;li&gt;
              &lt;a href="#/" class="selected"&gt;All&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
            &lt;a href="#/active"&gt;Active&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
            &lt;a href="#/completed"&gt;Completed&lt;/a&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;button class="clear-completed"&gt;Clear completed&lt;/button&gt;
        &lt;/footer&gt;
      &lt;/section&gt;
    &lt;/section&gt;
    &lt;footer class="info"&gt;
      &lt;p&gt;Double-click to edit a todo&lt;/p&gt;
      &lt;p&gt;Written by &lt;a href="http://twitter.com/KingstonTime/"&gt;Jonathan Kingston&lt;/a&gt;&lt;/p&gt;
      &lt;p&gt;Part of &lt;a href="http://todomvc.com"&gt;TodoMVC&lt;/a&gt;&lt;/p&gt;
    &lt;/footer&gt;

    &lt;script type="module" src="../js/index.js"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<ul>
<li>templates</li>
</ul>
<p>in <code>www/html/templates</code></p>
<ul>
<li>itemsLeft.html</li>
</ul>
<pre><code class="language-html">{{ active_todos }} item{% if active_todos &gt; 1 %}s{% endif %} left
</code></pre>
<ul>
<li>row.html</li>
</ul>
<pre><code class="language-html">&lt;li data-id="{{ id }}"{% if completed %} class="completed"{% endif %}&gt;
	&lt;div class="view"&gt;
		&lt;input class="toggle" type="checkbox"{% if completed %} checked{% endif %}&gt;
		&lt;label&gt;{{ title }}&lt;/label&gt;
		&lt;button class="destroy"&gt;&lt;/button&gt;
	&lt;/div&gt;
&lt;/li&gt;
</code></pre>
<ul>
<li>index.js</li>
</ul>
<pre><code class="language-js">// For more comments about what's going on here, check out the `hello_world`
// example
const rust = import('./pkg');
const css = import('./index.css');

rust
  .then(m =&gt; m.run())
  .catch(console.error);


</code></pre>
<ul>
<li>style.css</li>
</ul>
<pre><code class="language-css">html,
body {
	margin: 0;
	padding: 0;
}

button {
	margin: 0;
	padding: 0;
	border: 0;
	background: none;
	font-size: 100%;
	vertical-align: baseline;
	font-family: inherit;
	font-weight: inherit;
	color: inherit;
	-webkit-appearance: none;
	appearance: none;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

body {
	font: 14px 'Helvetica Neue', Helvetica, Arial, sans-serif;
	line-height: 1.4em;
	background: #f5f5f5;
	color: #4d4d4d;
	min-width: 230px;
	max-width: 550px;
	margin: 0 auto;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
	font-weight: 300;
}

:focus {
	outline: 0;
}

.hidden {
	display: none;
}

.todoapp {
	background: #fff;
	margin: 130px 0 40px 0;
	position: relative;
	box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
	            0 25px 50px 0 rgba(0, 0, 0, 0.1);
}

.todoapp input::-webkit-input-placeholder {
	font-style: italic;
	font-weight: 300;
	color: #e6e6e6;
}

.todoapp input::-moz-placeholder {
	font-style: italic;
	font-weight: 300;
	color: #e6e6e6;
}

.todoapp input::input-placeholder {
	font-style: italic;
	font-weight: 300;
	color: #e6e6e6;
}

.todoapp h1 {
	position: absolute;
	top: -155px;
	width: 100%;
	font-size: 100px;
	font-weight: 100;
	text-align: center;
	color: rgba(175, 47, 47, 0.15);
	-webkit-text-rendering: optimizeLegibility;
	-moz-text-rendering: optimizeLegibility;
	text-rendering: optimizeLegibility;
}

.new-todo,
.edit {
	position: relative;
	margin: 0;
	width: 100%;
	font-size: 24px;
	font-family: inherit;
	font-weight: inherit;
	line-height: 1.4em;
	border: 0;
	color: inherit;
	padding: 6px;
	border: 1px solid #999;
	box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
	box-sizing: border-box;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;
}

.new-todo {
	padding: 16px 16px 16px 60px;
	border: none;
	background: rgba(0, 0, 0, 0.003);
	box-shadow: inset 0 -2px 1px rgba(0,0,0,0.03);
}

.main {
	position: relative;
	z-index: 2;
	border-top: 1px solid #e6e6e6;
}

.toggle-all {
	width: 1px;
	height: 1px;
	border: none; /* Mobile Safari */
	opacity: 0;
	position: absolute;
	right: 100%;
	bottom: 100%;
}

.toggle-all + label {
	width: 60px;
	height: 34px;
	font-size: 0;
	position: absolute;
	top: -52px;
	left: -13px;
	-webkit-transform: rotate(90deg);
	transform: rotate(90deg);
}

.toggle-all + label:before {
	content: '❯';
	font-size: 22px;
	color: #e6e6e6;
	padding: 10px 27px 10px 27px;
}

.toggle-all:checked + label:before {
	color: #737373;
}

.todo-list {
	margin: 0;
	padding: 0;
	list-style: none;
}

.todo-list li {
	position: relative;
	font-size: 24px;
	border-bottom: 1px solid #ededed;
}

.todo-list li:last-child {
	border-bottom: none;
}

.todo-list li.editing {
	border-bottom: none;
	padding: 0;
}

.todo-list li.editing .edit {
	display: block;
	width: 506px;
	padding: 12px 16px;
	margin: 0 0 0 43px;
}

.todo-list li.editing .view {
	display: none;
}

.todo-list li .toggle {
	text-align: center;
	width: 40px;
	/* auto, since non-WebKit browsers doesn't support input styling */
	height: auto;
	position: absolute;
	top: 0;
	bottom: 0;
	margin: auto 0;
	border: none; /* Mobile Safari */
	-webkit-appearance: none;
	appearance: none;
}

.todo-list li .toggle {
	opacity: 0;
}

.todo-list li .toggle + label {
	/*
		Firefox requires `#` to be escaped - https://bugzilla.mozilla.org/show_bug.cgi?id=922433
		IE and Edge requires *everything* to be escaped to render, so we do that instead of just the `#` - https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/7157459/
	*/
	background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23ededed%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
	background-repeat: no-repeat;
	background-position: center left;
}

.todo-list li .toggle:checked + label {
	background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23bddad5%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%235dc2af%22%20d%3D%22M72%2025L42%2071%2027%2056l-4%204%2020%2020%2034-52z%22/%3E%3C/svg%3E');
}

.todo-list li label {
	word-break: break-all;
	padding: 15px 15px 15px 60px;
	display: block;
	line-height: 1.2;
	transition: color 0.4s;
}

.todo-list li.completed label {
	color: #d9d9d9;
	text-decoration: line-through;
}

.todo-list li .destroy {
	display: none;
	position: absolute;
	top: 0;
	right: 10px;
	bottom: 0;
	width: 40px;
	height: 40px;
	margin: auto 0;
	font-size: 30px;
	color: #cc9a9a;
	margin-bottom: 11px;
	transition: color 0.2s ease-out;
}

.todo-list li .destroy:hover {
	color: #af5b5e;
}

.todo-list li .destroy:after {
	content: '×';
}

.todo-list li:hover .destroy {
	display: block;
}

.todo-list li .edit {
	display: none;
}

.todo-list li.editing:last-child {
	margin-bottom: -1px;
}

.footer {
	color: #777;
	padding: 10px 15px;
	height: 20px;
	text-align: center;
	border-top: 1px solid #e6e6e6;
}

.footer:before {
	content: '';
	position: absolute;
	right: 0;
	bottom: 0;
	left: 0;
	height: 50px;
	overflow: hidden;
	box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
	            0 8px 0 -3px #f6f6f6,
	            0 9px 1px -3px rgba(0, 0, 0, 0.2),
	            0 16px 0 -6px #f6f6f6,
	            0 17px 2px -6px rgba(0, 0, 0, 0.2);
}

.todo-count {
	float: left;
	text-align: left;
}

.todo-count strong {
	font-weight: 300;
}

.filters {
	margin: 0;
	padding: 0;
	list-style: none;
	position: absolute;
	right: 0;
	left: 0;
}

.filters li {
	display: inline;
}

.filters li a {
	color: inherit;
	margin: 3px;
	padding: 3px 7px;
	text-decoration: none;
	border: 1px solid transparent;
	border-radius: 3px;
}

.filters li a:hover {
	border-color: rgba(175, 47, 47, 0.1);
}

.filters li a.selected {
	border-color: rgba(175, 47, 47, 0.2);
}

.clear-completed,
html .clear-completed:active {
	float: right;
	position: relative;
	line-height: 20px;
	text-decoration: none;
	cursor: pointer;
}

.clear-completed:hover {
	text-decoration: underline;
}

.info {
	margin: 65px auto 0;
	color: #bfbfbf;
	font-size: 10px;
	text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
	text-align: center;
}

.info p {
	line-height: 1;
}

.info a {
	color: inherit;
	text-decoration: none;
	font-weight: 400;
}

.info a:hover {
	text-decoration: underline;
}

/*
	Hack to remove background from Mobile Safari.
	Can't use it globally since it destroys checkboxes in Firefox
*/
@media screen and (-webkit-min-device-pixel-ratio:0) {
	.toggle-all,
	.todo-list li .toggle {
		background: none;
	}

	.todo-list li .toggle {
		height: 40px;
	}
}

@media (max-width: 430px) {
	.footer {
		height: 50px;
	}

	.filters {
		bottom: 10px;
	}
}
</code></pre>
<ul>
<li>Rust side</li>
</ul>
<ul>
<li>lib.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs
//! # TODO MVC
//!
//! A [TODO MVC](http://todomvc.com/) implementation written using [web-sys](https://rustwasm.github.io/wasm-bindgen/web-sys/overview.html)

use wasm_bindgen::prelude::*;

use std::rc::Rc;

/// Controller of the program
pub mod controller;
/// Element wrapper to the DOM
pub mod element;
/// Schedule messages to the Controller and View
pub mod scheduler;
/// Stores items into localstorage
pub mod store;
/// Handles constructing template strings from data
pub mod template;
/// Presentation layer
pub mod view;
use crate::controller::{Controller, ControllerMessage};
use crate::scheduler::Scheduler;
use crate::store::Store;
use crate::view::{View, ViewMessage};

/// Message wrapper enum used to pass through the scheduler to the Controller or View
pub enum Message {
    /// Message wrapper to send to the controller
    Controller(ControllerMessage),
    /// Message wrapper to send to the view
    View(ViewMessage),
}

/// Used for debugging to the console
pub fn exit(message: &amp;str) -&gt; ! {
    let v = wasm_bindgen::JsValue::from_str(message);
    web_sys::console::exception_1(&amp;v);
    std::process::abort()
}

fn app(name: &amp;str) {
    let sched = Rc::new(Scheduler::new());
    let store = match Store::new(name) {
        Some(s) =&gt; s,
        None =&gt; return,
    };
    let controller = Controller::new(store, Rc::downgrade(&amp;sched));
    if let Some(mut view) = View::new(Rc::clone(&amp;sched)) {
        let sch: &amp;Rc&lt;Scheduler&gt; = &amp;sched;
        view.init();
        sch.set_view(view);
        sch.set_controller(controller);
        sched.add_message(Message::Controller(ControllerMessage::SetPage(
            "".to_string(),
        )));
    }
}

/// Entry point into the program from JavaScript
#[wasm_bindgen(start)]
fn run() -&gt; Result&lt;(), JsValue&gt; {
    console_error_panic_hook::set_once();
    app("todos-wasmbindgen");

    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>controller.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Controller of the program
use crate::exit;
use crate::store::*;
use crate::view::ViewMessage;
use crate::{Message, Scheduler};
use js_sys::Date;

use std::cell::RefCell;
use std::rc::Weak;

/// The controller of the application turns page state into functionality
pub struct Controller {
    store: Store,
    sched: RefCell&lt;Option&lt;Weak&lt;Scheduler&gt;&gt;&gt;,
    active_route: String,
    last_active_route: String,
}

/// Messages that represent the methods to be called on the Controller
pub enum ControllerMessage {
    AddItem(String),
    SetPage(String),
    EditItemSave(String, String),
    ToggleItem(String, bool),
    EditItemCancel(String),
    RemoveCompleted(),
    RemoveItem(String),
    ToggleAll(bool),
}

impl Controller {
    pub fn new(store: Store, sched: Weak&lt;Scheduler&gt;) -&gt; Controller {
        Controller {
            store,
            sched: RefCell::new(Some(sched)),
            active_route: "".into(),
            last_active_route: "none".into(),
        }
    }

    /// Used by `Scheduler` to convert a `ControllerMessage` into a function call on a `Controller`
    pub fn call(&amp;mut self, method_name: ControllerMessage) {
        use self::ControllerMessage::*;
        match method_name {
            AddItem(title) =&gt; self.add_item(title),
            SetPage(hash) =&gt; self.set_page(hash),
            EditItemSave(id, value) =&gt; self.edit_item_save(id, value),
            EditItemCancel(id) =&gt; self.edit_item_cancel(id),
            RemoveCompleted() =&gt; self.remove_completed_items(),
            RemoveItem(id) =&gt; self.remove_item(&amp;id),
            ToggleAll(completed) =&gt; self.toggle_all(completed),
            ToggleItem(id, completed) =&gt; self.toggle_item(id, completed),
        }
    }

    fn toggle_item(&amp;mut self, id: String, completed: bool) {
        self.toggle_completed(id, completed);
        self._filter(completed);
    }

    fn add_message(&amp;self, view_message: ViewMessage) {
        if let Ok(sched) = self.sched.try_borrow_mut() {
            if let Some(ref sched) = *sched {
                if let Some(sched) = sched.upgrade() {
                    sched.add_message(Message::View(view_message));
                }
            }
        }
    }

    pub fn set_page(&amp;mut self, raw: String) {
        let route = raw.trim_start_matches("#/");
        self.active_route = route.to_string();
        self._filter(false);
        self.add_message(ViewMessage::UpdateFilterButtons(route.to_string()));
    }

    /// Add an Item to the Store and display it in the list.
    fn add_item(&amp;mut self, title: String) {
        self.store.insert(Item {
            id: Date::now().to_string(),
            title,
            completed: false,
        });
        self.add_message(ViewMessage::ClearNewTodo());
        self._filter(true);
    }

    /// Save an Item in edit.
    fn edit_item_save(&amp;mut self, id: String, title: String) {
        if !title.is_empty() {
            self.store.update(ItemUpdate::Title {
                id: id.clone(),
                title: title.clone(),
            });
            self.add_message(ViewMessage::EditItemDone(id.to_string(), title));
        } else {
            self.remove_item(&amp;id);
        }
    }

    /// Cancel the item editing mode.
    fn edit_item_cancel(&amp;mut self, id: String) {
        let mut message = None;
        if let Some(data) = self.store.find(ItemQuery::Id { id: id.clone() }) {
            if let Some(todo) = data.get(0) {
                let title = todo.title.to_string();
                message = Some(ViewMessage::EditItemDone(id, title));
            }
        }
        if let Some(message) = message {
            self.add_message(message);
        }
    }

    /// Remove the data and elements related to an Item.
    fn remove_item(&amp;mut self, id: &amp;String) {
        self.store.remove(ItemQuery::Id { id: id.clone() });
        self._filter(false);
        let ritem = id.to_string();
        self.add_message(ViewMessage::RemoveItem(ritem));
    }

    /// Remove all completed items.
    fn remove_completed_items(&amp;mut self) {
        self.store.remove(ItemQuery::Completed { completed: true });
        self._filter(true);
    }

    /// Update an Item in storage based on the state of completed.
    fn toggle_completed(&amp;mut self, id: String, completed: bool) {
        self.store.update(ItemUpdate::Completed {
            id: id.clone(),
            completed,
        });
        let tid = id;
        self.add_message(ViewMessage::SetItemComplete(tid, completed));
    }

    /// Set all items to complete or active.
    fn toggle_all(&amp;mut self, completed: bool) {
        let mut vals = Vec::new();
        if let Some(data) = self.store.find(ItemQuery::EmptyItemQuery) {
            vals.extend(data.iter().map(|item| item.id.clone()));
        }
        for id in vals.iter() {
            self.toggle_completed(id.to_string(), completed);
        }
        self._filter(false);
    }

    /// Refresh the list based on the current route.
    fn _filter(&amp;mut self, force: bool) {
        let route = &amp;self.active_route;

        if force || !self.last_active_route.is_empty() || &amp;self.last_active_route != route {
            let query = match route.as_str() {
                "completed" =&gt; ItemQuery::Completed { completed: true },
                "active" =&gt; ItemQuery::Completed { completed: false },
                _ =&gt; ItemQuery::EmptyItemQuery,
            };
            let mut v = None;
            {
                let store = &amp;mut self.store;
                if let Some(res) = store.find(query) {
                    v = Some(res.into());
                }
            }
            if let Some(res) = v {
                self.add_message(ViewMessage::ShowItems(res));
            }
        }

        if let Some((total, active, completed)) = self.store.count() {
            self.add_message(ViewMessage::SetItemsLeft(active));
            self.add_message(ViewMessage::SetClearCompletedButtonVisibility(
                completed &gt; 0,
            ));
            self.add_message(ViewMessage::SetCompleteAllCheckbox(completed == total));
            self.add_message(ViewMessage::SetMainVisibility(total &gt; 0));
        }

        self.last_active_route = route.to_string();
    }
}

impl Drop for Controller {
    fn drop(&amp;mut self) {
        exit("calling drop on Controller");
    }
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>element.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Element wrapper to the DOM
use wasm_bindgen::prelude::*;
use web_sys::EventTarget;

/// Wrapper for `web_sys::Element` to simplify calling different interfaces
pub struct Element {
    el: Option&lt;web_sys::Element&gt;,
}

impl From&lt;web_sys::Element&gt; for Element {
    fn from(el: web_sys::Element) -&gt; Element {
        Element { el: Some(el) }
    }
}

impl From&lt;web_sys::EventTarget&gt; for Element {
    fn from(el: web_sys::EventTarget) -&gt; Element {
        let el = wasm_bindgen::JsCast::dyn_into::&lt;web_sys::Element&gt;(el);
        Element { el: el.ok() }
    }
}

impl From&lt;Element&gt; for Option&lt;web_sys::Node&gt; {
    fn from(obj: Element) -&gt; Option&lt;web_sys::Node&gt; {
        obj.el.map(Into::into)
    }
}

impl From&lt;Element&gt; for Option&lt;EventTarget&gt; {
    fn from(obj: Element) -&gt; Option&lt;EventTarget&gt; {
        obj.el.map(Into::into)
    }
}

impl Element {
    // Create an element from a tag name
    pub fn create_element(tag: &amp;str) -&gt; Option&lt;Element&gt; {
        let el = web_sys::window()?.document()?.create_element(tag).ok()?;
        Some(el.into())
    }

    pub fn qs(selector: &amp;str) -&gt; Option&lt;Element&gt; {
        let body: web_sys::Element = web_sys::window()?.document()?.body()?.into();
        let el = body.query_selector(selector).ok()?;
        Some(Element { el })
    }

    /// Add event listener to this node
    pub fn add_event_listener&lt;T&gt;(&amp;mut self, event_name: &amp;str, handler: T)
    where
        T: 'static + FnMut(web_sys::Event),
    {
        let cb = Closure::new(handler);
        if let Some(el) = self.el.take() {
            let el_et: EventTarget = el.into();
            el_et
                .add_event_listener_with_callback(event_name, cb.as_ref().unchecked_ref())
                .unwrap();
            cb.forget();
            if let Ok(el) = el_et.dyn_into::&lt;web_sys::Element&gt;() {
                self.el = Some(el);
            }
        }
    }

    /// Delegate an event to a selector
    pub fn delegate&lt;T&gt;(
        &amp;mut self,
        selector: &amp;'static str,
        event: &amp;str,
        mut handler: T,
        use_capture: bool,
    ) where
        T: 'static + FnMut(web_sys::Event),
    {
        let el = match self.el.take() {
            Some(e) =&gt; e,
            None =&gt; return,
        };
        if let Some(dyn_el) = &amp;el.dyn_ref::&lt;EventTarget&gt;() {
            if let Some(window) = web_sys::window() {
                if let Some(document) = window.document() {
                    // TODO document selector to the target element
                    let tg_el = document;

                    let cb = Closure::new(move |event: web_sys::Event| {
                        if let Some(target_element) = event.target() {
                            let dyn_target_el: Option&lt;&amp;web_sys::Node&gt; =
                                wasm_bindgen::JsCast::dyn_ref(&amp;target_element);
                            if let Some(target_element) = dyn_target_el {
                                if let Ok(potential_elements) = tg_el.query_selector_all(selector) {
                                    let mut has_match = false;
                                    for i in 0..potential_elements.length() {
                                        if let Some(el) = potential_elements.get(i) {
                                            if target_element.is_equal_node(Some(&amp;el)) {
                                                has_match = true;
                                            }
                                            break;
                                        }
                                    }

                                    if has_match {
                                        handler(event);
                                    }
                                }
                            }
                        }
                    });

                    dyn_el
                        .add_event_listener_with_callback_and_bool(
                            event,
                            cb.as_ref().unchecked_ref(),
                            use_capture,
                        )
                        .unwrap();
                    cb.forget(); // TODO cycle collect
                }
            }
        }
        self.el = Some(el);
    }

    /// Find child `Element`s from this node
    pub fn qs_from(&amp;mut self, selector: &amp;str) -&gt; Option&lt;Element&gt; {
        let mut found_el = None;
        if let Some(el) = self.el.as_ref() {
            found_el = Some(Element {
                el: el.query_selector(selector).ok()?,
            });
        }
        found_el
    }

    /// Sets the inner HTML of the `self.el` element
    pub fn set_inner_html(&amp;mut self, value: String) {
        if let Some(el) = self.el.take() {
            el.set_inner_html(&amp;value);
            self.el = Some(el);
        }
    }

    /// Sets the text content of the `self.el` element
    pub fn set_text_content(&amp;mut self, value: &amp;str) {
        if let Some(el) = self.el.as_ref() {
            if let Some(node) = &amp;el.dyn_ref::&lt;web_sys::Node&gt;() {
                node.set_text_content(Some(value));
            }
        }
    }

    /// Gets the text content of the `self.el` element
    pub fn text_content(&amp;mut self) -&gt; Option&lt;String&gt; {
        let mut text = None;
        if let Some(el) = self.el.as_ref() {
            if let Some(node) = &amp;el.dyn_ref::&lt;web_sys::Node&gt;() {
                text = node.text_content();
            }
        }
        text
    }

    /// Gets the parent of the `self.el` element
    pub fn parent_element(&amp;mut self) -&gt; Option&lt;Element&gt; {
        let mut parent = None;
        if let Some(el) = self.el.as_ref() {
            if let Some(node) = &amp;el.dyn_ref::&lt;web_sys::Node&gt;() {
                if let Some(parent_node) = node.parent_element() {
                    parent = Some(parent_node.into());
                }
            }
        }
        parent
    }

    /// Gets the parent of the `self.el` element
    pub fn append_child(&amp;mut self, child: &amp;mut Element) {
        if let Some(el) = self.el.as_ref() {
            if let Some(node) = &amp;el.dyn_ref::&lt;web_sys::Node&gt;() {
                if let Some(ref child_el) = child.el {
                    if let Some(child_node) = child_el.dyn_ref::&lt;web_sys::Node&gt;() {
                        node.append_child(child_node).unwrap();
                    }
                }
            }
        }
    }

    /// Removes a class list item from the element
    ///
    /// ```
    /// e.class_list_remove(String::from("clickable"));
    /// // removes the class 'clickable' from e.el
    /// ```
    pub fn class_list_remove(&amp;mut self, value: &amp;str) {
        if let Some(el) = self.el.take() {
            el.class_list().remove_1(value).unwrap();
            self.el = Some(el);
        }
    }

    pub fn class_list_add(&amp;mut self, value: &amp;str) {
        if let Some(el) = self.el.take() {
            el.class_list().add_1(value).unwrap();
            self.el = Some(el);
        }
    }

    /// Given another `Element` it will remove that child from the DOM from this element
    /// Consumes `child` so it can't be used after it's removal.
    pub fn remove_child(&amp;mut self, mut child: Element) {
        if let Some(child_el) = child.el.take() {
            if let Some(el) = self.el.take() {
                if let Some(el_node) = el.dyn_ref::&lt;web_sys::Node&gt;() {
                    let child_node: web_sys::Node = child_el.into();
                    el_node.remove_child(&amp;child_node).unwrap();
                }
                self.el = Some(el);
            }
        }
    }

    /// Sets the whole class value for `self.el`
    pub fn set_class_name(&amp;mut self, class_name: &amp;str) {
        if let Some(el) = self.el.take() {
            el.set_class_name(class_name);
            self.el = Some(el);
        }
    }

    /// Sets the visibility for the element in `self.el`
    pub fn set_visibility(&amp;mut self, visible: bool) {
        if let Some(el) = self.el.take() {
            {
                let dyn_el: Option&lt;&amp;web_sys::HtmlElement&gt; = wasm_bindgen::JsCast::dyn_ref(&amp;el);
                if let Some(el) = dyn_el {
                    el.set_hidden(!visible);
                }
            }
            self.el = Some(el);
        }
    }

    pub fn blur(&amp;mut self) {
        if let Some(el) = self.el.take() {
            {
                let dyn_el: Option&lt;&amp;web_sys::HtmlElement&gt; = wasm_bindgen::JsCast::dyn_ref(&amp;el);
                if let Some(el) = dyn_el {
                    // There isn't much we can do with the result here so ignore
                    el.blur().unwrap();
                }
            }
            self.el = Some(el);
        }
    }

    pub fn focus(&amp;mut self) {
        if let Some(el) = self.el.take() {
            {
                let dyn_el: Option&lt;&amp;web_sys::HtmlElement&gt; = wasm_bindgen::JsCast::dyn_ref(&amp;el);
                if let Some(el) = dyn_el {
                    // There isn't much we can do with the result here so ignore
                    el.focus().unwrap();
                }
            }
            self.el = Some(el);
        }
    }

    pub fn dataset_set(&amp;mut self, key: &amp;str, value: &amp;str) {
        if let Some(el) = self.el.take() {
            {
                if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlElement&gt;(&amp;el) {
                    el.dataset().set(key, value).unwrap();
                }
            }
            self.el = Some(el);
        }
    }

    pub fn dataset_get(&amp;mut self, key: &amp;str) -&gt; String {
        let mut text = String::new();
        if let Some(el) = self.el.take() {
            {
                if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlElement&gt;(&amp;el) {
                    if let Some(value) = el.dataset().get(key) {
                        text = value;
                    }
                }
            }
            self.el = Some(el);
        }
        text
    }

    /// Sets the value for the element in `self.el` (The element must be an input)
    pub fn set_value(&amp;mut self, value: &amp;str) {
        if let Some(el) = self.el.take() {
            if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;el) {
                el.set_value(value);
            }
            self.el = Some(el);
        }
    }

    /// Gets the value for the element in `self.el` (The element must be an input)
    pub fn value(&amp;mut self) -&gt; String {
        let mut v = String::new();
        if let Some(el) = self.el.take() {
            if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;el) {
                v = el.value();
            }
            self.el = Some(el);
        }
        v
    }

    /// Sets the checked state for the element in `self.el` (The element must be an input)
    pub fn set_checked(&amp;mut self, checked: bool) {
        if let Some(el) = self.el.take() {
            if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;el) {
                el.set_checked(checked);
            }
            self.el = Some(el);
        }
    }

    /// Gets the checked state for the element in `self.el` (The element must be an input)
    pub fn checked(&amp;mut self) -&gt; bool {
        let mut checked = false;
        if let Some(el) = self.el.take() {
            if let Some(el) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;el) {
                checked = el.checked();
            }
            self.el = Some(el);
        }
        checked
    }
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>scheduler.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Schedule messages to the Controller and View
use crate::controller::Controller;
use crate::exit;
use crate::view::View;
use crate::Message;
use std::cell::RefCell;
use std::rc::Rc;

/// Creates an event loop that starts each time a message is added
pub struct Scheduler {
    controller: Rc&lt;RefCell&lt;Option&lt;Controller&gt;&gt;&gt;,
    view: Rc&lt;RefCell&lt;Option&lt;View&gt;&gt;&gt;,
    events: RefCell&lt;Vec&lt;Message&gt;&gt;,
    running: RefCell&lt;bool&gt;,
}

fn deadlock() -&gt; ! {
    exit("This might be a deadlock");
}

impl Scheduler {
    /// Construct a new `Scheduler`
    pub fn new() -&gt; Scheduler {
        Scheduler {
            controller: Rc::new(RefCell::new(None)),
            view: Rc::new(RefCell::new(None)),
            events: RefCell::new(Vec::new()),
            running: RefCell::new(false),
        }
    }

    pub fn set_controller(&amp;self, controller: Controller) {
        if let Ok(mut controller_data) = self.controller.try_borrow_mut() {
            *controller_data = Some(controller);
        } else {
            deadlock()
        }
    }

    pub fn set_view(&amp;self, view: View) {
        if let Ok(mut view_data) = self.view.try_borrow_mut() {
            *view_data = Some(view);
        } else {
            deadlock()
        }
    }

    /// Add a new message onto the event stack
    ///
    /// Triggers running the event loop if it's not already running
    pub fn add_message(&amp;self, message: Message) {
        let running = if let Ok(running) = self.running.try_borrow() {
            *running
        } else {
            deadlock()
        };
        if let Ok(mut events) = self.events.try_borrow_mut() {
            events.push(message);
        } else {
            deadlock()
        }
        if !running {
            self.run();
        }
    }

    /// Start the event loop, taking messages from the stack to run
    fn run(&amp;self) {
        let events_len = if let Ok(events) = self.events.try_borrow() {
            events.len()
        } else {
            deadlock()
        };
        if events_len == 0 {
            if let Ok(mut running) = self.running.try_borrow_mut() {
                *running = false;
            } else {
                deadlock()
            }
        } else {
            if let Ok(mut running) = self.running.try_borrow_mut() {
                *running = true;
            } else {
                deadlock()
            }
            self.next_message();
        }
    }

    fn next_message(&amp;self) {
        let event = if let Ok(mut events) = self.events.try_borrow_mut() {
            events.pop()
        } else {
            deadlock()
        };
        if let Some(event) = event {
            match event {
                Message::Controller(e) =&gt; {
                    if let Ok(mut controller) = self.controller.try_borrow_mut() {
                        if let Some(ref mut ag) = *controller {
                            ag.call(e);
                        }
                    } else {
                        deadlock()
                    }
                }
                Message::View(e) =&gt; {
                    if let Ok(mut view) = self.view.try_borrow_mut() {
                        if let Some(ref mut ag) = *view {
                            ag.call(e);
                        }
                    } else {
                        deadlock()
                    }
                }
            }
            self.run();
        } else if let Ok(mut running) = self.running.try_borrow_mut() {
            *running = false;
        } else {
            deadlock()
        }
    }
}

impl Drop for Scheduler {
    fn drop(&amp;mut self) {
        exit("calling drop on Scheduler");
    }
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>store.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Stores items into localstorage
use js_sys::JSON;
use wasm_bindgen::prelude::*;

/// Stores items into localstorage
pub struct Store {
    local_storage: web_sys::Storage,
    data: ItemList,
    name: String,
}

impl Store {
    /// Creates a new store with `name` as the localstorage value name
    pub fn new(name: &amp;str) -&gt; Option&lt;Store&gt; {
        let window = web_sys::window()?;
        if let Ok(Some(local_storage)) = window.local_storage() {
            let mut store = Store {
                local_storage,
                data: ItemList::new(),
                name: String::from(name),
            };
            store.fetch_local_storage();
            Some(store)
        } else {
            None
        }
    }

    /// Read the local ItemList from localStorage.
    /// Returns an &amp;Option&lt;ItemList&gt; of the stored database
    /// Caches the store into `self.data` to reduce calls to JS
    ///
    /// Uses mut here as the return is something we might want to manipulate
    ///
    fn fetch_local_storage(&amp;mut self) -&gt; Option&lt;()&gt; {
        let mut item_list = ItemList::new();
        // If we have an existing cached value, return early.
        if let Ok(Some(value)) = self.local_storage.get_item(&amp;self.name) {
            let data = JSON::parse(&amp;value).ok()?;
            let iter = js_sys::try_iter(&amp;data).ok()??;
            for item in iter {
                let item = item.ok()?;
                let item_array: &amp;js_sys::Array = wasm_bindgen::JsCast::dyn_ref(&amp;item)?;
                let title = item_array.shift().as_string()?;
                let completed = item_array.shift().as_bool()?;
                let id = item_array.shift().as_string()?;
                let temp_item = Item {
                    title,
                    completed,
                    id,
                };
                item_list.push(temp_item);
            }
        }
        self.data = item_list;
        Some(())
    }

    /// Write the local ItemList to localStorage.
    fn sync_local_storage(&amp;mut self) {
        let array = js_sys::Array::new();
        for item in self.data.iter() {
            let child = js_sys::Array::new();
            child.push(&amp;JsValue::from(&amp;item.title));
            child.push(&amp;JsValue::from(item.completed));
            child.push(&amp;JsValue::from(&amp;item.id));

            array.push(&amp;JsValue::from(child));
        }
        if let Ok(storage_string) = JSON::stringify(&amp;JsValue::from(array)) {
            let storage_string: String = storage_string.into();
            self.local_storage
                .set_item(&amp;self.name, &amp;storage_string)
                .unwrap();
        }
    }

    /// Find items with properties matching those on query.
    /// `ItemQuery` query Query to match
    ///
    /// ```
    ///  let data = db.find(ItemQuery::Completed {completed: true});
    ///  // data will contain items whose completed properties are true
    /// ```
    pub fn find(&amp;mut self, query: ItemQuery) -&gt; Option&lt;ItemListSlice&lt;'_&gt;&gt; {
        Some(
            self.data
                .iter()
                .filter(|todo| query.matches(todo))
                .collect(),
        )
    }

    /// Update an item in the Store.
    ///
    /// `ItemUpdate` update Record with an id and a property to update
    pub fn update(&amp;mut self, update: ItemUpdate) {
        let id = update.id();
        self.data.iter_mut().for_each(|todo| {
            if id == todo.id {
                todo.update(&amp;update);
            }
        });
        self.sync_local_storage();
    }

    /// Insert an item into the Store.
    ///
    /// `Item` item Item to insert
    pub fn insert(&amp;mut self, item: Item) {
        self.data.push(item);
        self.sync_local_storage();
    }

    /// Remove items from the Store based on a query.
    /// query is an `ItemQuery` query Query matching the items to remove
    pub fn remove(&amp;mut self, query: ItemQuery) {
        self.data.retain(|todo| !query.matches(todo));
        self.sync_local_storage();
    }

    /// Count total, active, and completed todos.
    pub fn count(&amp;mut self) -&gt; Option&lt;(usize, usize, usize)&gt; {
        self.find(ItemQuery::EmptyItemQuery).map(|data| {
            let total = data.length();

            let mut completed = 0;
            for item in data.iter() {
                if item.completed {
                    completed += 1;
                }
            }
            (total, total - completed, completed)
        })
    }
}

/// Represents a todo item
pub struct Item {
    pub id: String,
    pub title: String,
    pub completed: bool,
}

impl Item {
    pub fn update(&amp;mut self, update: &amp;ItemUpdate) {
        match update {
            ItemUpdate::Title { title, .. } =&gt; {
                self.title = title.to_string();
            }
            ItemUpdate::Completed { completed, .. } =&gt; {
                self.completed = *completed;
            }
        }
    }
}

pub trait ItemListTrait&lt;T&gt; {
    fn new() -&gt; Self;
    fn get(&amp;self, i: usize) -&gt; Option&lt;&amp;T&gt;;
    fn length(&amp;self) -&gt; usize;
    fn push(&amp;mut self, item: T);
    fn iter(&amp;self) -&gt; std::slice::Iter&lt;'_, T&gt;;
}

pub struct ItemList {
    list: Vec&lt;Item&gt;,
}
impl ItemList {
    fn retain&lt;F&gt;(&amp;mut self, f: F)
    where
        F: FnMut(&amp;Item) -&gt; bool,
    {
        self.list.retain(f);
    }
    fn iter_mut(&amp;mut self) -&gt; std::slice::IterMut&lt;'_, Item&gt; {
        self.list.iter_mut()
    }
}
impl ItemListTrait&lt;Item&gt; for ItemList {
    fn new() -&gt; ItemList {
        ItemList { list: Vec::new() }
    }
    fn get(&amp;self, i: usize) -&gt; Option&lt;&amp;Item&gt; {
        self.list.get(i)
    }
    fn length(&amp;self) -&gt; usize {
        self.list.len()
    }
    fn push(&amp;mut self, item: Item) {
        self.list.push(item)
    }
    fn iter(&amp;self) -&gt; std::slice::Iter&lt;'_, Item&gt; {
        self.list.iter()
    }
}
use std::iter::FromIterator;
impl FromIterator&lt;Item&gt; for ItemList {
    fn from_iter&lt;I: IntoIterator&lt;Item = Item&gt;&gt;(iter: I) -&gt; Self {
        let mut c = ItemList::new();
        for i in iter {
            c.push(i);
        }

        c
    }
}

/// A borrowed set of Items filtered from the store
pub struct ItemListSlice&lt;'a&gt; {
    list: Vec&lt;&amp;'a Item&gt;,
}

impl&lt;'a&gt; ItemListTrait&lt;&amp;'a Item&gt; for ItemListSlice&lt;'a&gt; {
    fn new() -&gt; ItemListSlice&lt;'a&gt; {
        ItemListSlice { list: Vec::new() }
    }
    fn get(&amp;self, i: usize) -&gt; Option&lt;&amp;&amp;'a Item&gt; {
        self.list.get(i)
    }
    fn length(&amp;self) -&gt; usize {
        self.list.len()
    }
    fn push(&amp;mut self, item: &amp;'a Item) {
        self.list.push(item)
    }
    fn iter(&amp;self) -&gt; std::slice::Iter&lt;'_, &amp;'a Item&gt; {
        self.list.iter()
    }
}

impl&lt;'a&gt; FromIterator&lt;&amp;'a Item&gt; for ItemListSlice&lt;'a&gt; {
    fn from_iter&lt;I: IntoIterator&lt;Item = &amp;'a Item&gt;&gt;(iter: I) -&gt; Self {
        let mut c = ItemListSlice::new();
        for i in iter {
            c.push(i);
        }
        c
    }
}

impl From&lt;ItemListSlice&lt;'_&gt;&gt; for ItemList {
    fn from(s: ItemListSlice&lt;'_&gt;) -&gt; Self {
        let mut i = ItemList::new();
        let items = s.list.into_iter();
        for j in items {
            // TODO neaten this cloning?
            let item = Item {
                id: j.id.clone(),
                completed: j.completed,
                title: j.title.clone(),
            };
            i.push(item);
        }
        i
    }
}

/// Represents a search into the store
pub enum ItemQuery {
    Id { id: String },
    Completed { completed: bool },
    EmptyItemQuery,
}

impl ItemQuery {
    fn matches(&amp;self, item: &amp;Item) -&gt; bool {
        match *self {
            ItemQuery::EmptyItemQuery =&gt; true,
            ItemQuery::Id { ref id } =&gt; &amp;item.id == id,
            ItemQuery::Completed { completed } =&gt; item.completed == completed,
        }
    }
}

pub enum ItemUpdate {
    Title { id: String, title: String },
    Completed { id: String, completed: bool },
}

impl ItemUpdate {
    fn id(&amp;self) -&gt; String {
        match self {
            ItemUpdate::Title { id, .. } =&gt; id.clone(),
            ItemUpdate::Completed { id, .. } =&gt; id.clone(),
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>template.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Handles constructing template strings from data
use crate::store::{ItemList, ItemListTrait};
use askama::Template as AskamaTemplate;

#[derive(AskamaTemplate)]
#[template(path = "row.html")]
struct RowTemplate&lt;'a&gt; {
    id: &amp;'a str,
    title: &amp;'a str,
    completed: bool,
}

#[derive(AskamaTemplate)]
#[template(path = "itemsLeft.html")]
struct ItemsLeftTemplate {
    active_todos: usize,
}

pub struct Template {}

impl Template {
    /// Format the contents of a todo list.
    ///
    /// items `ItemList` contains keys you want to find in the template to replace.
    /// Returns the contents for a todo list
    ///
    pub fn item_list(items: ItemList) -&gt; String {
        let mut output = String::from("");
        for item in items.iter() {
            let row = RowTemplate {
                id: &amp;item.id,
                completed: item.completed,
                title: &amp;item.title,
            };
            if let Ok(res) = row.render() {
                output.push_str(&amp;res);
            }
        }
        output
    }

    ///
    /// Format the contents of an "items left" indicator.
    ///
    /// `active_todos` Number of active todos
    ///
    /// Returns the contents for an "items left" indicator
    pub fn item_counter(active_todos: usize) -&gt; String {
        let items_left = ItemsLeftTemplate { active_todos };
        if let Ok(res) = items_left.render() {
            res
        } else {
            String::new()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>view.rs</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Presentation layer
use crate::controller::ControllerMessage;
use crate::element::Element;
use crate::exit;
use crate::store::ItemList;
use crate::{Message, Scheduler};
use std::cell::RefCell;
use std::rc::Rc;

use crate::template::Template;

const ENTER_KEY: u32 = 13;
const ESCAPE_KEY: u32 = 27;

use wasm_bindgen::prelude::*;

/// Messages that represent the methods to be called on the View
pub enum ViewMessage {
    UpdateFilterButtons(String),
    ClearNewTodo(),
    ShowItems(ItemList),
    SetItemsLeft(usize),
    SetClearCompletedButtonVisibility(bool),
    SetCompleteAllCheckbox(bool),
    SetMainVisibility(bool),
    RemoveItem(String),
    EditItemDone(String, String),
    SetItemComplete(String, bool),
}
fn item_id(mut element: Element) -&gt; Option&lt;String&gt; {
    element.parent_element().map(|mut parent| {
        let mut res = None;
        let parent_id = parent.dataset_get("id");
        if !parent_id.is_empty() {
            res = Some(parent_id);
        } else if let Some(mut ep) = parent.parent_element() {
            res = Some(ep.dataset_get("id"));
        }
        res.unwrap()
    })
}

/// Presentation layer
#[wasm_bindgen]
pub struct View {
    sched: RefCell&lt;Rc&lt;Scheduler&gt;&gt;,
    todo_list: Element,
    todo_item_counter: Element,
    clear_completed: Element,
    main: Element,
    toggle_all: Element,
    new_todo: Element,
    callbacks: Vec&lt;(web_sys::EventTarget, String, Closure&lt;dyn FnMut()&gt;)&gt;,
}

impl View {
    /// Construct a new view
    pub fn new(sched: Rc&lt;Scheduler&gt;) -&gt; Option&lt;View&gt; {
        let todo_list = Element::qs(".todo-list")?;
        let todo_item_counter = Element::qs(".todo-count")?;
        let clear_completed = Element::qs(".clear-completed")?;
        let main = Element::qs(".main")?;
        let toggle_all = Element::qs(".toggle-all")?;
        let new_todo = Element::qs(".new-todo")?;
        Some(View {
            sched: RefCell::new(sched),
            todo_list,
            todo_item_counter,
            clear_completed,
            main,
            toggle_all,
            new_todo,
            callbacks: Vec::new(),
        })
    }

    pub fn init(&amp;mut self) {
        let window = match web_sys::window() {
            Some(w) =&gt; w,
            None =&gt; return,
        };
        let document = match window.document() {
            Some(d) =&gt; d,
            None =&gt; return,
        };
        let sched = self.sched.clone();
        let set_page = Closure::&lt;dyn FnMut()&gt;::new(move || {
            if let Some(location) = document.location() {
                if let Ok(hash) = location.hash() {
                    if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                        sched.add_message(Message::Controller(ControllerMessage::SetPage(hash)));
                    }
                }
            }
        });

        let window_et: web_sys::EventTarget = window.into();
        window_et
            .add_event_listener_with_callback("hashchange", set_page.as_ref().unchecked_ref())
            .unwrap();
        set_page.forget(); // Cycle collect this
                           //self.callbacks.push((window_et, "hashchange".to_string(), set_page));
        self.bind_add_item();
        self.bind_edit_item_save();
        self.bind_edit_item_cancel();
        self.bind_remove_item();
        self.bind_toggle_item();
        self.bind_edit_item();
        self.bind_remove_completed();
        self.bind_toggle_all();
    }

    fn bind_edit_item(&amp;mut self) {
        self.todo_list.delegate(
            "li label",
            "dblclick",
            |e: web_sys::Event| {
                if let Some(target) = e.target() {
                    View::edit_item(target.into());
                }
            },
            false,
        );
    }

    /// Put an item into edit mode.
    fn edit_item(mut el: Element) {
        if let Some(mut parent_element) = el.parent_element() {
            if let Some(mut list_item) = parent_element.parent_element() {
                list_item.class_list_add("editing");
                if let Some(mut input) = Element::create_element("input") {
                    input.set_class_name("edit");
                    if let Some(text) = el.text_content() {
                        input.set_value(&amp;text);
                    }
                    list_item.append_child(&amp;mut input);
                    input.focus();
                }
            }
        }
    }

    /// Used by scheduler to convert a `ViewMessage` into a function call on the `View`
    pub fn call(&amp;mut self, method_name: ViewMessage) {
        use self::ViewMessage::*;
        match method_name {
            UpdateFilterButtons(route) =&gt; self.update_filter_buttons(&amp;route),
            ClearNewTodo() =&gt; self.clear_new_todo(),
            ShowItems(item_list) =&gt; self.show_items(item_list),
            SetItemsLeft(count) =&gt; self.set_items_left(count),
            SetClearCompletedButtonVisibility(visible) =&gt; {
                self.set_clear_completed_button_visibility(visible)
            }
            SetCompleteAllCheckbox(complete) =&gt; self.set_complete_all_checkbox(complete),
            SetMainVisibility(complete) =&gt; self.set_main_visibility(complete),
            RemoveItem(id) =&gt; self.remove_item(&amp;id),
            EditItemDone(id, title) =&gt; self.edit_item_done(&amp;id, &amp;title),
            SetItemComplete(id, completed) =&gt; self.set_item_complete(&amp;id, completed),
        }
    }

    /// Populate the todo list with a list of items.
    fn show_items(&amp;mut self, items: ItemList) {
        self.todo_list.set_inner_html(Template::item_list(items));
    }

    /// Gets the selector to find a todo item in the DOM
    fn get_selector_string(id: &amp;str) -&gt; String {
        let mut selector = String::from("[data-id=\"");
        selector.push_str(id);
        selector.push_str("\"]");
        selector
    }

    /// Remove an item from the view.
    fn remove_item(&amp;mut self, id: &amp;str) {
        let elem = Element::qs(&amp;View::get_selector_string(id));

        if let Some(elem) = elem {
            self.todo_list.remove_child(elem);
        }
    }

    /// Set the number in the 'items left' display.
    fn set_items_left(&amp;mut self, items_left: usize) {
        self.todo_item_counter
            .set_inner_html(Template::item_counter(items_left));
    }

    /// Set the visibility of the "Clear completed" button.
    fn set_clear_completed_button_visibility(&amp;mut self, visible: bool) {
        self.clear_completed.set_visibility(visible);
    }

    /// Set the visibility of the main content and footer.
    fn set_main_visibility(&amp;mut self, visible: bool) {
        self.main.set_visibility(visible);
    }

    /// Set the checked state of the Complete All checkbox.
    fn set_complete_all_checkbox(&amp;mut self, checked: bool) {
        self.toggle_all.set_checked(checked);
    }

    /// Change the appearance of the filter buttons based on the route.
    fn update_filter_buttons(&amp;self, route: &amp;str) {
        if let Some(mut el) = Element::qs(".filters .selected") {
            el.set_class_name("");
        }

        let mut selector = String::from(".filters [href=\"");
        selector.push_str(route);
        selector.push_str("\"]");

        if let Some(mut el) = Element::qs(&amp;selector) {
            el.set_class_name("selected");
        }
    }

    /// Clear the new todo input
    fn clear_new_todo(&amp;mut self) {
        self.new_todo.set_value("");
    }

    /// Render an item as either completed or not.
    fn set_item_complete(&amp;self, id: &amp;str, completed: bool) {
        if let Some(mut list_item) = Element::qs(&amp;View::get_selector_string(id)) {
            let class_name = if completed { "completed" } else { "" };
            list_item.set_class_name(class_name);

            // In case it was toggled from an event and not by clicking the checkbox
            if let Some(mut el) = list_item.qs_from("input") {
                el.set_checked(completed);
            }
        }
    }

    /// Bring an item out of edit mode.
    fn edit_item_done(&amp;self, id: &amp;str, title: &amp;str) {
        if let Some(mut list_item) = Element::qs(&amp;View::get_selector_string(id)) {
            if let Some(input) = list_item.qs_from("input.edit") {
                list_item.class_list_remove("editing");

                if let Some(mut list_item_label) = list_item.qs_from("label") {
                    list_item_label.set_text_content(title);
                }

                list_item.remove_child(input);
            }
        }
    }

    fn bind_add_item(&amp;mut self) {
        let sched = self.sched.clone();
        let cb = move |event: web_sys::Event| {
            if let Some(target) = event.target() {
                if let Some(input_el) =
                    wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;target)
                {
                    let v = input_el.value(); // TODO remove with nll
                    let title = v.trim();
                    if !title.is_empty() {
                        if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                            sched.add_message(Message::Controller(ControllerMessage::AddItem(
                                String::from(title),
                            )));
                        }
                    }
                }
            }
        };
        self.new_todo.add_event_listener("change", cb);
    }

    fn bind_remove_completed(&amp;mut self) {
        let sched = self.sched.clone();
        let handler = move |_| {
            if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                sched.add_message(Message::Controller(ControllerMessage::RemoveCompleted()));
            }
        };
        self.clear_completed.add_event_listener("click", handler);
    }

    fn bind_toggle_all(&amp;mut self) {
        let sched = self.sched.clone();
        self.toggle_all
            .add_event_listener("click", move |event: web_sys::Event| {
                if let Some(target) = event.target() {
                    if let Some(input_el) =
                        wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::HtmlInputElement&gt;(&amp;target)
                    {
                        if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                            sched.add_message(Message::Controller(ControllerMessage::ToggleAll(
                                input_el.checked(),
                            )));
                        }
                    }
                }
            });
    }

    fn bind_remove_item(&amp;mut self) {
        let sched = self.sched.clone();
        self.todo_list.delegate(
            ".destroy",
            "click",
            move |e: web_sys::Event| {
                if let Some(target) = e.target() {
                    let el: Element = target.into();
                    if let Some(item_id) = item_id(el) {
                        if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                            sched.add_message(Message::Controller(ControllerMessage::RemoveItem(
                                item_id,
                            )));
                        }
                    }
                }
            },
            false,
        );
    }

    fn bind_toggle_item(&amp;mut self) {
        let sched = self.sched.clone();
        self.todo_list.delegate(
            ".toggle",
            "click",
            move |e: web_sys::Event| {
                if let Some(target) = e.target() {
                    let mut el: Element = target.into();
                    let checked = el.checked();
                    if let Some(item_id) = item_id(el) {
                        if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                            sched.add_message(Message::Controller(ControllerMessage::ToggleItem(
                                item_id, checked,
                            )));
                        }
                    }
                }
            },
            false,
        );
    }

    fn bind_edit_item_save(&amp;mut self) {
        let sched = self.sched.clone();

        self.todo_list.delegate(
            "li .edit",
            "blur",
            move |e: web_sys::Event| {
                if let Some(target) = e.target() {
                    let mut target_el: Element = target.into();
                    if target_el.dataset_get("iscancelled") != "true" {
                        let val = target_el.value();
                        if let Some(item) = item_id(target_el) {
                            // TODO refactor back into fn
                            // Was: &amp;self.add_message(ControllerMessage::SetPage(hash));
                            if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                                sched.add_message(Message::Controller(
                                    ControllerMessage::EditItemSave(item, val),
                                ));
                            }
                            // TODO refactor back into fn
                        }
                    }
                }
            },
            true,
        );

        // Remove the cursor from the input when you hit enter just like if it were a real form
        self.todo_list.delegate(
            "li .edit",
            "keypress",
            |e: web_sys::Event| {
                if let Some(key_e) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::KeyboardEvent&gt;(&amp;e) {
                    if key_e.key_code() == ENTER_KEY {
                        if let Some(target) = e.target() {
                            let mut el: Element = target.into();
                            el.blur();
                        }
                    }
                }
            },
            false,
        );
    }

    fn bind_edit_item_cancel(&amp;mut self) {
        let sched = self.sched.clone();
        self.todo_list.delegate(
            "li .edit",
            "keyup",
            move |e: web_sys::Event| {
                if let Some(key_e) = wasm_bindgen::JsCast::dyn_ref::&lt;web_sys::KeyboardEvent&gt;(&amp;e) {
                    if key_e.key_code() == ESCAPE_KEY {
                        if let Some(target) = e.target() {
                            let mut el: Element = target.into();
                            el.dataset_set("iscanceled", "true");
                            el.blur();
                            if let Some(item_id) = item_id(el) {
                                if let Ok(sched) = &amp;(sched.try_borrow_mut()) {
                                    sched.add_message(Message::Controller(
                                        ControllerMessage::EditItemCancel(item_id),
                                    ));
                                }
                            }
                        }
                    }
                }
            },
            false,
        );
    }
}

impl Drop for View {
    fn drop(&amp;mut self) {
        for callback in self.callbacks.drain(..) {
            callback
                .0
                .remove_event_listener_with_callback(
                    callback.1.as_str(),
                    callback.2.as_ref().unchecked_ref(),
                )
                .unwrap();
        }
        exit("calling drop on view");
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>build</li>
</ul>
<p>Adding in TODO MVC example using web-sys</p>
<pre><pre class="playground"><code class="language-rust">extern crate askama;

fn main() {
    askama::rerun_if_templates_changed();
}</code></pre></pre>
<h3 id="running-the-demo-2"><a class="header" href="#running-the-demo-2">Running the demo</a></h3>
<p>"<em>Currently it's required to use the --target no-modules or --target web flag with wasm-bindgen to run threaded code. This is because the WebAssembly file imports memory instead of exporting it, so we need to hook initialization of the wasm module at this time to provide the appropriate memory object. This demo uses --target no-modules, because Firefox does not support modules in workers.</em></p>
<p><em>With --target no-modules you'll be able to use importScripts inside of each web worker to import the shim JS generated by wasm-bindgen as well as calling the wasm_bindgen initialization function with the shared memory instance from the main thread. The expected usage is that WebAssembly on the main thread will post its memory object to all other threads to get instantiated with.</em>"<br />
_ <a href="https://rustwasm.github.io/wasm-bindgen/examples/raytrace-parallel.html">wasm-bindgen Guide</a>{target="_blank"}</p>
<h2 id="build-and-serve-16"><a class="header" href="#build-and-serve-16">build and serve</a></h2>
<blockquote>
<p>This example requires to <em>not</em> create ES modules, therefore we pass the flag
<code>--target no-modules</code></p>
</blockquote>
<pre><code class="language-sh">wasm-pack build --target no-modules --no-typescript --out-dir www/pkg

http www
</code></pre>
<p>open <code>index.html</code></p>
<pre><code class="language-sh">firefox http://localhost:8000/html/
</code></pre>
<p>NOTE:</p>
<em>
Size
<p>The size of the project hasn't undergone much work to make it optimised yet.</p>
<pre><code>~96kb release build
~76kb optimised with binaryen
~28kb brotli compressed
</code></pre>
</em>
[wasm-bindgen guide](https://rustwasm.github.io/wasm-bindgen/examples/todomvc.html)
---
<h2 id="whats-next-19"><a class="header" href="#whats-next-19">What's next?</a></h2>
<p>Were are done for now.</p>
</main>
<script src="https://lerina.github.io/js/toc.js"></script>
<script>
let anchor= document.createElement('a');
anchor.href="javascript:closeNav()"; //void(0)"; //anchor[0].onclick = closeNav();
anchor.className = "closebtn";  
anchor.innerHTML="&times;";
document.getElementById("TOC").prepend(anchor);
<p>let navCrumbs= document.createElement('div');
navCrumbs.className = "hover-nav";
navCrumbs.innerHTML = `</p>
<div class="hover-nav">
<ul>
<li><a href="../../../../index.html">⇦ home</a></li>
<li><a href="../index.html">hello_world</a></li>
</ul>
</div>`;
document.getElementById("TOC").prepend(navCrumbs); 
</script>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
